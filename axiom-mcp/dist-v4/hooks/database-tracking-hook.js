/**
 * Database Tracking Hook - Populates database with execution data
 * This is what was missing! No hook was actually writing to the database.
 */
import { HookEvent } from '../core/hook-orchestrator.js';
import { Logger } from '../core/logger.js';
import { v4 as uuidv4 } from 'uuid';
const logger = Logger.getInstance();
export const databaseTrackingHook = {
    name: 'database-tracking-hook',
    events: [
        HookEvent.EXECUTION_STARTED,
        HookEvent.EXECUTION_STREAM,
        HookEvent.EXECUTION_COMPLETED,
        HookEvent.EXECUTION_FAILED
    ],
    priority: 90, // Run early to ensure database is populated
    handler: async (context) => {
        const { event, execution, stream, request, db } = context;
        if (!db) {
            logger.warn('DatabaseTrackingHook', 'handler', 'No database in context');
            return { action: 'continue' };
        }
        const taskId = execution?.taskId || uuidv4();
        try {
            switch (event) {
                case HookEvent.EXECUTION_STARTED:
                    logger.info('DatabaseTrackingHook', 'EXECUTION_STARTED', 'Creating conversation', { taskId });
                    // Create conversation - ID is auto-generated by the DB
                    const conversationId = await db.createConversation({
                        parent_id: null,
                        started_at: new Date().toISOString(),
                        status: 'active',
                        depth: 0,
                        prompt: request?.args?.prompt || request?.args?.parentPrompt || '',
                        task_type: request?.tool || 'axiom_spawn',
                        metadata: {
                            verboseMasterMode: request?.args?.verboseMasterMode || false,
                            spawnPattern: request?.args?.spawnPattern || 'single',
                            timestamp: new Date().toISOString(),
                            originalTaskId: taskId
                        }
                    });
                    // Store the actual conversation ID for later use
                    context.execution.taskId = conversationId;
                    await db.logAction({
                        conversation_id: conversationId,
                        type: 'execution_started',
                        content: 'Task execution started',
                        metadata: { event: 'EXECUTION_STARTED' }
                    });
                    break;
                case HookEvent.EXECUTION_STREAM:
                    const streamData = stream?.data || '';
                    // Get the actual conversation ID from context
                    const convId = context.execution?.taskId || taskId;
                    // Log stream data
                    await db.logStream({
                        conversation_id: convId,
                        chunk: streamData
                    });
                    // Also log significant events as actions
                    if (streamData.includes('[AXIOM')) {
                        await db.logAction({
                            conversation_id: convId,
                            type: 'axiom_event',
                            content: streamData.slice(0, 100),
                            metadata: { stream: true }
                        });
                    }
                    break;
                case HookEvent.EXECUTION_COMPLETED: {
                    logger.info('DatabaseTrackingHook', 'EXECUTION_COMPLETED', 'Updating conversation', { taskId });
                    const convId = context.execution?.taskId || taskId;
                    await db.updateConversation(convId, {
                        status: 'completed',
                        metadata: {
                            completed_at: new Date().toISOString(),
                            output: execution?.output || ''
                        }
                    });
                    await db.logAction({
                        conversation_id: convId,
                        type: 'execution_completed',
                        content: 'Task execution completed successfully',
                        metadata: { event: 'EXECUTION_COMPLETED' }
                    });
                    break;
                }
                case HookEvent.EXECUTION_FAILED: {
                    logger.error('DatabaseTrackingHook', 'EXECUTION_FAILED', 'Task failed', {
                        taskId,
                        error: context.metadata?.error
                    });
                    const convId = context.execution?.taskId || taskId;
                    await db.updateConversation(convId, {
                        status: 'failed',
                        metadata: {
                            failed_at: new Date().toISOString(),
                            error: context.metadata?.error || 'Unknown error'
                        }
                    });
                    await db.logAction({
                        conversation_id: convId,
                        type: 'execution_failed',
                        content: `Task failed: ${context.metadata?.error || 'Unknown error'}`,
                        metadata: {
                            event: 'EXECUTION_FAILED',
                            error: context.metadata?.error
                        }
                    });
                    break;
                }
            }
        }
        catch (error) {
            logger.error('DatabaseTrackingHook', 'handler', 'Database operation failed', {
                taskId,
                event,
                error: error instanceof Error ? error.message : String(error)
            });
        }
        return { action: 'continue' };
    }
};
export default databaseTrackingHook;
//# sourceMappingURL=database-tracking-hook.js.map