#!/usr/bin/env python3
"""
USD SABR Volatility Surface Calibration using QuantLib
This would be generated by Axiom MCP with the task:
"Create USD volatility grid calibration using QuantLib"
"""

import QuantLib as ql
import numpy as np
import pandas as pd
from typing import List, Tuple, Dict
from datetime import datetime, date

class USDSABRCalibrator:
    """Calibrate SABR model to USD swaption volatilities"""
    
    def __init__(self, valuation_date: date):
        self.valuation_date = ql.Date(valuation_date.day, valuation_date.month, valuation_date.year)
        ql.Settings.instance().evaluationDate = self.valuation_date
        
        # USD market conventions
        self.calendar = ql.UnitedStates(ql.UnitedStates.FederalReserve)
        self.day_count = ql.Actual360()
        self.business_convention = ql.ModifiedFollowing
        
        # SOFR curve setup (replacing LIBOR)
        self.setup_yield_curve()
        
    def setup_yield_curve(self):
        """Setup USD SOFR yield curve"""
        # Market quotes for SOFR curve construction
        deposits = [
            (ql.Period(1, ql.Days), 0.0530),    # O/N
            (ql.Period(1, ql.Weeks), 0.0531),   # 1W
            (ql.Period(1, ql.Months), 0.0532),  # 1M
            (ql.Period(3, ql.Months), 0.0540),  # 3M
        ]
        
        swaps = [
            (ql.Period(1, ql.Years), 0.0545),
            (ql.Period(2, ql.Years), 0.0550),
            (ql.Period(3, ql.Years), 0.0555),
            (ql.Period(5, ql.Years), 0.0560),
            (ql.Period(7, ql.Years), 0.0565),
            (ql.Period(10, ql.Years), 0.0570),
            (ql.Period(15, ql.Years), 0.0575),
            (ql.Period(20, ql.Years), 0.0580),
            (ql.Period(30, ql.Years), 0.0585),
        ]
        
        # Build curve with deposits and swaps
        helpers = []
        
        # Deposit rate helpers
        for tenor, rate in deposits:
            helpers.append(ql.DepositRateHelper(
                ql.QuoteHandle(ql.SimpleQuote(rate)),
                tenor,
                2,  # fixing days
                self.calendar,
                self.business_convention,
                True,
                self.day_count
            ))
        
        # Swap rate helpers
        sofr_index = ql.Sofr()
        for tenor, rate in swaps:
            helpers.append(ql.SwapRateHelper(
                ql.QuoteHandle(ql.SimpleQuote(rate)),
                tenor,
                self.calendar,
                ql.Annual,
                self.business_convention,
                self.day_count,
                sofr_index
            ))
        
        # Build the curve
        self.yield_curve = ql.PiecewiseLogCubicDiscount(
            self.valuation_date,
            helpers,
            self.day_count
        )
        
        self.yield_handle = ql.YieldTermStructureHandle(self.yield_curve)
        
    def create_swaption_grid(self) -> Dict[Tuple[int, int], float]:
        """Create grid of ATM swaption volatilities (expiry, tenor) -> vol"""
        # Typical USD swaption volatility grid (in %)
        # These would come from Bloomberg/Reuters in production
        vol_grid = {
            # (expiry_years, swap_tenor_years): volatility
            (1, 1): 65.2,    (1, 2): 58.3,    (1, 5): 45.7,    (1, 10): 38.2,
            (2, 1): 55.8,    (2, 2): 52.1,    (2, 5): 42.3,    (2, 10): 36.5,
            (3, 1): 48.7,    (3, 2): 46.9,    (3, 5): 40.1,    (3, 10): 35.2,
            (5, 1): 42.3,    (5, 2): 41.5,    (5, 5): 37.8,    (5, 10): 33.9,
            (10, 1): 35.6,   (10, 2): 35.2,   (10, 5): 33.4,   (10, 10): 31.2,
        }
        
        # Convert to decimal
        return {k: v/100.0 for k, v in vol_grid.items()}
    
    def calibrate_sabr(self, expiry_years: int, tenor_years: int, 
                      atm_vol: float, vol_smile: List[Tuple[float, float]] = None) -> Dict[str, float]:
        """
        Calibrate SABR parameters for a specific expiry/tenor pair
        
        Args:
            expiry_years: Option expiry in years
            tenor_years: Underlying swap tenor in years  
            atm_vol: ATM volatility
            vol_smile: List of (strike_offset, vol) for smile calibration
            
        Returns:
            Dictionary with SABR parameters: alpha, beta, nu, rho
        """
        # Calculate forward swap rate
        expiry_date = self.calendar.advance(self.valuation_date, ql.Period(expiry_years, ql.Years))
        
        # Create swap to get forward rate
        forward_rate = self.yield_curve.forwardRate(
            expiry_date,
            self.calendar.advance(expiry_date, ql.Period(tenor_years, ql.Years)),
            self.day_count,
            ql.Compounded,
            ql.Annual
        ).rate()
        
        # SABR calibration
        strikes = [forward_rate]  # ATM
        vols = [atm_vol]
        
        # Add smile points if provided
        if vol_smile:
            for offset, vol in vol_smile:
                strikes.append(forward_rate + offset)
                vols.append(vol)
        
        # Initial guess for SABR parameters
        alpha = atm_vol * forward_rate ** 0.8  # Initial alpha
        beta = 0.7  # Typical for rates
        nu = 0.3    # Vol of vol
        rho = -0.3  # Correlation
        
        # For simplicity, using approximate calibration
        # In production, would use QuantLib's SABR calibration engine
        time_to_expiry = expiry_years
        
        # Simplified SABR calibration (would use optimization in practice)
        sabr_params = {
            'alpha': alpha,
            'beta': beta,
            'nu': nu,
            'rho': rho,
            'forward': forward_rate,
            'expiry': time_to_expiry
        }
        
        return sabr_params
    
    def build_full_surface(self) -> pd.DataFrame:
        """Build and calibrate the full SABR volatility surface"""
        vol_grid = self.create_swaption_grid()
        results = []
        
        for (expiry, tenor), atm_vol in vol_grid.items():
            params = self.calibrate_sabr(expiry, tenor, atm_vol)
            
            results.append({
                'expiry': expiry,
                'tenor': tenor,
                'atm_vol': atm_vol,
                'forward': params['forward'],
                'alpha': params['alpha'],
                'beta': params['beta'],
                'nu': params['nu'],
                'rho': params['rho']
            })
        
        return pd.DataFrame(results)
    
    def calculate_vol(self, params: Dict[str, float], strike: float) -> float:
        """Calculate SABR implied volatility for a given strike"""
        # Hagan's SABR formula implementation
        f = params['forward']
        k = strike
        t = params['expiry']
        alpha = params['alpha']
        beta = params['beta']
        nu = params['nu']
        rho = params['rho']
        
        if abs(f - k) < 1e-12:  # ATM
            v = alpha / (f ** (1 - beta))
            return v
        
        # Full SABR formula (simplified version)
        fk_beta = (f * k) ** ((1 - beta) / 2)
        log_fk = np.log(f / k)
        z = nu / alpha * fk_beta * log_fk
        x = np.log((np.sqrt(1 - 2*rho*z + z**2) + z - rho) / (1 - rho))
        
        prefix = alpha / (fk_beta * x / z)
        
        return prefix


def main():
    """Example usage"""
    print("USD SABR Volatility Surface Calibration")
    print("=" * 50)
    
    # Initialize calibrator
    cal_date = date(2024, 1, 8)
    calibrator = USDSABRCalibrator(cal_date)
    
    # Build full surface
    print("\nCalibrating SABR surface...")
    surface_df = calibrator.build_full_surface()
    
    # Display results
    print("\nCalibration Results:")
    print(surface_df.to_string(index=False))
    
    # Save to CSV
    surface_df.to_csv('usd_sabr_surface.csv', index=False)
    print("\nResults saved to usd_sabr_surface.csv")
    
    # Example: Price a specific swaption
    print("\nExample Swaption Pricing:")
    expiry = 5
    tenor = 10
    strike_offset = 0.005  # 50bps above ATM
    
    # Get SABR parameters for 5Y10Y
    params_5y10y = surface_df[(surface_df['expiry'] == expiry) & 
                              (surface_df['tenor'] == tenor)].iloc[0].to_dict()
    
    # Calculate vol for off-strike
    strike = params_5y10y['forward'] + strike_offset
    vol = calibrator.calculate_vol(params_5y10y, strike)
    
    print(f"5Y10Y Swaption, Strike: {strike:.2%}, Vol: {vol:.1%}")


if __name__ == "__main__":
    main()