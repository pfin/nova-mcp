This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
core/
  debug-logger.ts
  event-bus.ts
  hook-orchestrator.ts
  logger.ts
  simple-logger.ts
  task-manager.ts
database/
  conversation-db.ts
executors/
  claude-session-manager.ts
  command-executor.ts
  pty-executor.ts
  session-based-executor.ts
  simple-executor.ts
hooks/
  conversation-db.ts
  database-tracking-hook.ts
  enhanced-verbose-hook.ts
  event-bus.ts
  interrupt-handler-hook.ts
  intervention-hook.ts
  monitoring-dashboard-hook.ts
  parallel-execution-hook.ts
  task-decomposition-hook.ts
  universal-principles-hook.ts
  validation-hook.ts
  verbose-monitor-hook.ts
  websocket-monitor-hook.ts
managers/
  status-manager.ts
resources/
  task-monitor-resource.ts
tools/
  axiom-claude-orchestrate.ts
ARCHITECTURE.md
demo-interrupt.ts
index.ts
test-interrupt.ts

================================================================
Files
================================================================

================
File: core/debug-logger.ts
================
import * as fs from 'fs/promises';
import * as path from 'path';

export class DebugLogger {
  private static instance: DebugLogger;
  private logFile: string;
  private buffer: string[] = [];
  private flushTimer?: NodeJS.Timeout;
  
  private constructor() {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    this.logFile = path.join('/home/peter/nova-mcp/axiom-mcp/logs-v4', `debug-${timestamp}.log`);
    this.startFlushTimer();
  }
  
  static getInstance(): DebugLogger {
    if (!DebugLogger.instance) {
      DebugLogger.instance = new DebugLogger();
    }
    return DebugLogger.instance;
  }
  
  async log(component: string, message: string, data?: any): Promise<void> {
    const timestamp = new Date().toISOString();
    const logLine = `[${timestamp}] [${component}] ${message}${data ? ' ' + JSON.stringify(data) : ''}\n`;
    this.buffer.push(logLine);
    
    // Also write to stderr for immediate visibility
    process.stderr.write(logLine);
    
    // Flush if buffer is getting large
    if (this.buffer.length > 100) {
      await this.flush();
    }
  }
  
  private startFlushTimer(): void {
    this.flushTimer = setInterval(() => {
      this.flush().catch(err => {
        process.stderr.write(`Failed to flush debug log: ${err}\n`);
      });
    }, 1000); // Flush every second
  }
  
  async flush(): Promise<void> {
    if (this.buffer.length === 0) return;
    
    const content = this.buffer.join('');
    this.buffer = [];
    
    try {
      await fs.appendFile(this.logFile, content);
    } catch (err) {
      process.stderr.write(`Failed to write to debug log: ${err}\n`);
    }
  }
  
  getLogFile(): string {
    return this.logFile;
  }
  
  async shutdown(): Promise<void> {
    if (this.flushTimer) {
      clearInterval(this.flushTimer);
    }
    await this.flush();
  }
}

// Export singleton instance
export const debugLog = DebugLogger.getInstance();

================
File: core/event-bus.ts
================
import * as fs from 'fs/promises';
import * as path from 'path';
import { HookEvent } from './hook-orchestrator.js';

export interface EventLogEntry {
  timestamp: string;
  taskId: string;
  workerId: string;
  event: string;
  payload: any;
}

export class EventBus {
  private logStream?: fs.FileHandle;
  private logPath: string;
  private hookOrchestrator?: any;
  
  constructor(logsDir: string = 'logs-v4') {
    this.logPath = path.join(logsDir, `axiom-events-${Date.now()}.jsonl`);
  }
  
  // v4 addition: Set hook orchestrator
  setHookOrchestrator(orchestrator: any): void {
    this.hookOrchestrator = orchestrator;
  }
  
  async initialize(): Promise<void> {
    // Ensure logs directory exists
    await fs.mkdir(path.dirname(this.logPath), { recursive: true });
    
    // Open log file for appending
    this.logStream = await fs.open(this.logPath, 'a');
    
    // Only log in debug mode
    if (process.env.AXIOM_LOG_LEVEL === 'DEBUG' || process.env.AXIOM_LOG_LEVEL === 'TRACE') {
      console.error(`[EventBus] Logging to ${this.logPath}`);
    }
  }
  
  async logEvent(entry: EventLogEntry): Promise<void> {
    const line = JSON.stringify(entry) + '\n';
    
    if (this.logStream) {
      await this.logStream.write(line);
    }
    
    // v4: Trigger hooks for event logging
    if (this.hookOrchestrator) {
      await this.hookOrchestrator.triggerHooks('EVENT_LOGGED', { entry });
    }
    
    // Also log critical events to stderr
    if (entry.event === 'error' || entry.event === 'intervention') {
      console.error(`[EventBus] ${entry.event}:`, entry.payload);
    }
  }
  
  async getRecentEvents(limit: number = 100): Promise<EventLogEntry[]> {
    try {
      const content = await fs.readFile(this.logPath, 'utf-8');
      const lines = content.trim().split('\n').filter(l => l);
      const events = lines.slice(-limit).map(line => JSON.parse(line));
      return events;
    } catch (error) {
      return [];
    }
  }
  
  async searchEvents(filter: {
    taskId?: string;
    event?: string;
    startTime?: string;
    endTime?: string;
  }): Promise<EventLogEntry[]> {
    try {
      const content = await fs.readFile(this.logPath, 'utf-8');
      const lines = content.trim().split('\n').filter(l => l);
      
      return lines
        .map(line => JSON.parse(line))
        .filter(entry => {
          if (filter.taskId && entry.taskId !== filter.taskId) return false;
          if (filter.event && entry.event !== filter.event) return false;
          if (filter.startTime && entry.timestamp < filter.startTime) return false;
          if (filter.endTime && entry.timestamp > filter.endTime) return false;
          return true;
        });
    } catch (error) {
      return [];
    }
  }
  
  async getEventStats(): Promise<Record<string, number>> {
    try {
      const content = await fs.readFile(this.logPath, 'utf-8');
      const lines = content.trim().split('\n').filter(l => l);
      
      const stats: Record<string, number> = {};
      
      for (const line of lines) {
        const entry = JSON.parse(line);
        stats[entry.event] = (stats[entry.event] || 0) + 1;
      }
      
      return stats;
    } catch (error) {
      return {};
    }
  }
  
  async close(): Promise<void> {
    if (this.logStream) {
      await this.logStream.close();
    }
  }
}

================
File: core/hook-orchestrator.ts
================
/**
 * Axiom v4 - Hook-First Architecture
 * HookOrchestrator is the central hub for ALL execution
 */

import { EventEmitter } from 'events';
import { Logger } from './logger.js';
import { logDebug } from './simple-logger.js';

export enum HookEvent {
  // Request lifecycle
  REQUEST_RECEIVED = 'request_received',
  REQUEST_VALIDATED = 'request_validated',
  REQUEST_BLOCKED = 'request_blocked',
  
  // Execution lifecycle  
  EXECUTION_STARTED = 'execution_started',
  EXECUTION_STREAM = 'execution_stream',
  EXECUTION_INTERVENTION = 'execution_intervention',
  EXECUTION_COMPLETED = 'execution_completed',
  EXECUTION_FAILED = 'execution_failed',
  
  // Monitoring events
  MONITOR_ATTACH = 'monitor_attach',
  MONITOR_DETACH = 'monitor_detach',
  
  // Parallel execution
  PARALLEL_SPAWN = 'parallel_spawn',
  PARALLEL_MERGE = 'parallel_merge',
}

export interface HookContext {
  event: HookEvent;
  request?: {
    tool: string;
    args: any;
  };
  execution?: {
    taskId: string;
    status: string;
    output?: string;
  };
  stream?: {
    data: string;
    source: string;
  };
  metadata?: Record<string, any>;
  // v4: Access to core components
  db?: any;
  eventBus?: any;
  statusManager?: any;
}

export interface HookResult {
  action: 'continue' | 'block' | 'modify' | 'redirect';
  reason?: string;
  modifications?: any;
  redirect?: {
    tool: string;
    args: any;
  };
}

export type HookHandler = (context: HookContext) => Promise<HookResult>;

export interface Hook {
  name: string;
  events: HookEvent[];
  priority: number;
  handler: HookHandler;
}

export class HookOrchestrator extends EventEmitter {
  private hooks: Map<HookEvent | string, Hook[]> = new Map();
  private db: any; // ConversationDB
  private eventBus: any; // EventBus
  private statusManager: any; // StatusManager
  private executors: Map<string, any> = new Map();
  private monitors: Set<any> = new Set();
  private activeTasks: Map<string, any> = new Map(); // Track active background tasks
  private logger: Logger;
  
  constructor(db: any, eventBus: any, statusManager?: any) {
    super();
    this.db = db;
    this.eventBus = eventBus;
    this.statusManager = statusManager;
    this.logger = Logger.getInstance();
  }
  
  /**
   * Register a hook
   */
  registerHook(hook: Hook): void {
    this.logger.info('HookOrchestrator', 'registerHook', 'Registering hook', {
      name: hook.name,
      events: hook.events,
      priority: hook.priority
    });
    
    for (const event of hook.events) {
      const eventHooks = this.hooks.get(event) || [];
      eventHooks.push(hook);
      // Sort by priority (higher first)
      eventHooks.sort((a, b) => b.priority - a.priority);
      this.hooks.set(event, eventHooks);
    }
    
    this.logger.debug('HookOrchestrator', 'registerHook', 'Hook registered successfully', {
      name: hook.name,
      totalHooks: Array.from(this.hooks.values()).flat().length
    });
  }
  
  /**
   * Main entry point - ALL requests go through here
   */
  async handleRequest(tool: string, args: any): Promise<any> {
    const taskId = `task-${Date.now()}`;
    logDebug('ORCHESTRATOR', `handleRequest START - tool: ${tool}, taskId: ${taskId}`);
    logDebug('ORCHESTRATOR', 'args:', args);
    
    this.logger.info('HookOrchestrator', 'handleRequest', 'Request received', { tool, taskId, args });
    
    const context: HookContext = {
      event: HookEvent.REQUEST_RECEIVED,
      request: { tool, args },
      execution: { taskId, status: 'pending' },
      metadata: { taskId }
    };
    
    // Phase 1: Request validation hooks
    logDebug('ORCHESTRATOR', 'Phase 1: Triggering validation hooks');
    const validationResult = await this.triggerHooks(HookEvent.REQUEST_RECEIVED, context);
    logDebug('ORCHESTRATOR', 'Validation result:', validationResult);
    
    if (validationResult.action === 'block') {
      await this.triggerHooks(HookEvent.REQUEST_BLOCKED, {
        ...context,
        metadata: { reason: validationResult.reason }
      });
      throw new Error(validationResult.reason || 'Request blocked by hook');
    }
    
    if (validationResult.action === 'redirect') {
      // Redirect to different tool
      return this.handleRequest(
        validationResult.redirect!.tool,
        validationResult.redirect!.args
      );
    }
    
    // Apply any modifications
    if (validationResult.modifications) {
      args = { ...args, ...validationResult.modifications };
    }
    
    // Phase 2: Execution
    context.request!.args = args;
    context.execution!.status = 'running';
    
    logDebug('ORCHESTRATOR', 'Phase 2: Starting execution');
    await this.triggerHooks(HookEvent.EXECUTION_STARTED, context);
    
    try {
      // Get executor through hooks (allows dynamic executor selection)
      logDebug('ORCHESTRATOR', `Selecting executor for tool: ${tool}`);
      const executor = await this.selectExecutor(tool, args);
      logDebug('ORCHESTRATOR', `Executor selected: ${executor.constructor.name}`);
      
      // Set up stream monitoring
      const streamHandler = async (data: string) => {
        this.logger.trace('HookOrchestrator', 'streamHandler', 'Stream data received', {
          taskId,
          dataLength: data.length,
          preview: data.slice(0, 50)
        });
        
        // CRITICAL: Check for claude --print IMMEDIATELY
        if (data.includes('claude --print') || data.includes('claude -p')) {
          logDebug('ORCHESTRATOR', 'CRITICAL: claude --print detected in stream!');
          this.logger.error('HookOrchestrator', 'streamHandler', 'CRITICAL: claude --print detected', { taskId });
          
          // Immediate intervention
          if (executor.interrupt) {
            executor.interrupt();
          }
          
          const intervention = '\n[AXIOM CRITICAL] STOP! Do NOT use "claude --print" or "claude -p"!\n' +
                             'claude --print CANNOT be course-corrected once started.\n' +
                             'You can only kill it, not redirect it. This breaks the entire intervention model.\n' +
                             'Use interactive claude session instead for bidirectional communication.\n\n';
          
          if (executor.injectCommand) {
            await executor.injectCommand(intervention);
          } else if (executor.write) {
            executor.write(intervention);
          }
          
          // Notify through stream
          if (args.notificationSender) {
            await args.notificationSender(taskId, intervention);
          }
          
          // Mark task as failed
          const task = this.activeTasks.get(taskId);
          if (task) {
            task.status = 'failed';
            task.error = 'claude --print detected and blocked';
          }
          
          // Don't process further
          return;
        }
        
        const streamContext: HookContext = {
          ...context,
          event: HookEvent.EXECUTION_STREAM,
          stream: { data, source: taskId }
        };
        
        const streamResult = await this.triggerHooks(HookEvent.EXECUTION_STREAM, streamContext);
        
        // Check for interventions
        if (streamResult.action === 'modify') {
          this.logger.warn('HookOrchestrator', 'streamHandler', 'Intervention detected', {
            taskId,
            command: streamResult.modifications?.command
          });
          
          // Inject intervention command
          if (executor.injectCommand) {
            await executor.injectCommand(streamResult.modifications.command);
            this.logger.info('HookOrchestrator', 'streamHandler', 'Intervention injected', { taskId });
          }
        }
        
        // Update task output
        const task = this.activeTasks.get(taskId);
        if (task) {
          task.output += data;
          if (!task.streamData) task.streamData = [];
          task.streamData.push(data);
        }
        
        // Send notification if sender provided
        if (args.notificationSender) {
          try {
            await args.notificationSender(taskId, data);
          } catch (error) {
            this.logger.warn('HookOrchestrator', 'streamHandler', 'Failed to send notification', { taskId, error });
          }
        }
        
        // Notify monitors
        this.notifyMonitors('stream', { taskId, data });
      };
      
      // Check if verbose mode is enabled
      const isVerbose = args.verboseMasterMode === true;
      logDebug('ORCHESTRATOR', `Verbose mode: ${isVerbose}`);
      
      if (isVerbose) {
        logDebug('ORCHESTRATOR', 'VERBOSE MODE - Starting non-blocking execution');
        // Track task info
        const taskInfo = {
          taskId,
          status: 'running',
          startTime: Date.now(),
          prompt: args.prompt || args.parentPrompt || '',
          output: '',
          streamData: [],
          executor: executor  // Store executor reference for sending messages
        };
        this.activeTasks.set(taskId, taskInfo);
        
        // NON-BLOCKING: Start execution without awaiting
        logDebug('ORCHESTRATOR', 'Starting executor.execute without await');
        const executionPromise = executor.execute.length === 4
          ? executor.execute(
              args.prompt || args.parentPrompt || '',
              args.systemPrompt || '',
              taskId,
              streamHandler
            )
          : executor.execute(args, streamHandler);
        logDebug('ORCHESTRATOR', 'Execution started in background');
        
        // Handle completion in background
        executionPromise
          .then(async (output: any) => {
            const task = this.activeTasks.get(taskId);
            if (task) {
              task.status = 'completed';
              task.output = output;
              task.endTime = Date.now();
            }
            context.execution!.status = 'completed';
            context.execution!.output = output;
            await this.triggerHooks(HookEvent.EXECUTION_COMPLETED, context);
            this.logger.info('HookOrchestrator', 'backgroundExecution', 'Task completed', { taskId });
          })
          .catch(async (error: any) => {
            const task = this.activeTasks.get(taskId);
            if (task) {
              task.status = 'failed';
              task.error = error instanceof Error ? error.message : String(error);
              task.endTime = Date.now();
            }
            context.execution!.status = 'failed';
            context.metadata = { error: error instanceof Error ? error.message : String(error) };
            await this.triggerHooks(HookEvent.EXECUTION_FAILED, context);
            this.logger.error('HookOrchestrator', 'backgroundExecution', 'Task failed', { taskId, error });
          });
        
        // Return immediately with task info
        logDebug('ORCHESTRATOR', 'Returning immediate response for verbose mode');
        const response = {
          taskId,
          status: 'executing',
          message: args.notificationSender 
            ? 'Task started. Output streaming via notifications.' 
            : 'Task started in background. Use axiom_output to check progress.',
          instructions: {
            monitor: args.notificationSender 
              ? 'Watch notifications for real-time output' 
              : 'Use axiom_output to read accumulated output',
            interrupt: 'Use axiom_send to communicate with task',
            completion: 'Task will complete or fail asynchronously',
            checkStatus: `Use axiom_status to check progress`
          }
        };
        logDebug('ORCHESTRATOR', 'Response:', response);
        return response;
      } else {
        // BLOCKING: Traditional mode waits for completion
        logDebug('ORCHESTRATOR', 'BLOCKING MODE - Awaiting execution completion');
        let result;
        if (executor.execute.length === 4) {
          logDebug('ORCHESTRATOR', 'Calling executor.execute with 4 params');
          result = await executor.execute(
            args.prompt || args.parentPrompt || '',
            args.systemPrompt || '',
            taskId,
            streamHandler
          );
        } else {
          logDebug('ORCHESTRATOR', 'Calling executor.execute with args');
          result = await executor.execute(args, streamHandler);
        }
        logDebug('ORCHESTRATOR', 'Execution completed, result type:', typeof result);
        
        context.execution!.status = 'completed';
        context.execution!.output = result;
        
        await this.triggerHooks(HookEvent.EXECUTION_COMPLETED, context);
        
        return result;
      }
      
    } catch (error) {
      context.execution!.status = 'failed';
      context.metadata = { error: error instanceof Error ? error.message : String(error) };
      
      await this.triggerHooks(HookEvent.EXECUTION_FAILED, context);
      throw error;
    }
  }
  
  /**
   * Trigger hooks for an event
   */
  async triggerHooks(event: HookEvent | string, context: Partial<HookContext>): Promise<HookResult> {
    const timerKey = `hooks-${event}-${Date.now()}`;
    this.logger.startTimer(timerKey);
    
    this.logger.debug('HookOrchestrator', 'triggerHooks', `Triggering hooks for event: ${event}`, {
      event,
      hooksCount: this.hooks.get(event)?.length || 0,
      taskId: context.execution?.taskId
    });
    
    // Build full context
    const fullContext: HookContext = {
      event: event as HookEvent,
      db: this.db,
      eventBus: this.eventBus,
      statusManager: this.statusManager,
      ...context
    };
    
    const hooks = this.hooks.get(event) || [];
    let result: HookResult = { action: 'continue' };
    
    for (const hook of hooks) {
      try {
        this.logger.logHook(hook.name, event.toString(), 'start');
        const hookResult = await hook.handler(fullContext);
        this.logger.logHook(hook.name, event.toString(), 'end', hookResult);
        
        // First blocking/redirecting hook wins
        if (hookResult.action !== 'continue') {
          const duration = this.logger.endTimer(timerKey);
          this.logger.info('HookOrchestrator', 'triggerHooks', `Hook ${hook.name} blocked/redirected execution`, {
            event,
            action: hookResult.action,
            reason: hookResult.reason,
            duration
          });
          return hookResult;
        }
        
        // Accumulate modifications
        if (hookResult.modifications) {
          result.modifications = {
            ...result.modifications,
            ...hookResult.modifications
          };
        }
      } catch (error) {
        this.logger.error('HookOrchestrator', 'triggerHooks', `Error in hook ${hook.name}`, {
          event,
          error: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : undefined
        });
        // Log but don't fail - hooks should be resilient
      }
    }
    
    const duration = this.logger.endTimer(timerKey);
    this.logger.debug('HookOrchestrator', 'triggerHooks', 'Hooks completed', {
      event,
      duration,
      modifications: result.modifications ? Object.keys(result.modifications) : []
    });
    
    return result;
  }
  
  /**
   * Select executor based on tool and args
   */
  private async selectExecutor(tool: string, args: any): Promise<any> {
    this.logger.debug('HookOrchestrator', 'selectExecutor', 'Selecting executor', { tool, executors: Array.from(this.executors.keys()) });
    
    // This can be overridden by hooks
    const executor = this.executors.get(tool);
    if (!executor) {
      this.logger.error('HookOrchestrator', 'selectExecutor', 'No executor found', { tool });
      throw new Error(`No executor registered for tool: ${tool}`);
    }
    
    this.logger.debug('HookOrchestrator', 'selectExecutor', 'Executor selected', { tool, executorType: executor.constructor?.name });
    return executor;
  }
  
  /**
   * Register an executor
   */
  registerExecutor(tool: string, executor: any): void {
    this.executors.set(tool, executor);
  }
  
  /**
   * Attach a monitor (VerboseMonitor, WebSocket, etc)
   */
  attachMonitor(monitor: any): void {
    this.monitors.add(monitor);
    this.triggerHooks(HookEvent.MONITOR_ATTACH, {
      event: HookEvent.MONITOR_ATTACH,
      metadata: { monitor: monitor.constructor.name }
    });
  }
  
  /**
   * Notify all monitors
   */
  private notifyMonitors(event: string, data: any): void {
    for (const monitor of this.monitors) {
      if (monitor.notify) {
        monitor.notify(event, data);
      }
    }
  }
  
  /**
   * Enable parallel execution through hooks
   */
  async spawnParallel(requests: Array<{ tool: string; args: any }>): Promise<any[]> {
    await this.triggerHooks(HookEvent.PARALLEL_SPAWN, {
      event: HookEvent.PARALLEL_SPAWN,
      metadata: { count: requests.length }
    });
    
    // Execute in parallel
    const results = await Promise.all(
      requests.map(req => this.handleRequest(req.tool, req.args))
    );
    
    // Merge results through hooks
    const mergeResult = await this.triggerHooks(HookEvent.PARALLEL_MERGE, {
      event: HookEvent.PARALLEL_MERGE,
      metadata: { results }
    });
    
    return mergeResult.modifications?.mergedResult || results;
  }
  
  /**
   * Get status of active tasks
   */
  getTaskStatus(taskId?: string): any {
    if (taskId) {
      return this.activeTasks.get(taskId);
    }
    // Return all active tasks
    const tasks = [];
    for (const [id, task] of this.activeTasks) {
      tasks.push({ id, ...task });
    }
    return tasks;
  }
  
  /**
   * Clear completed/failed tasks
   */
  clearCompletedTasks(): void {
    for (const [id, task] of this.activeTasks) {
      if (task.status === 'completed' || task.status === 'failed') {
        this.activeTasks.delete(id);
      }
    }
  }
  
  /**
   * Get an active task by ID (alias for getTaskStatus)
   */
  getActiveTask(taskId: string): any {
    return this.activeTasks.get(taskId);
  }
  
  /**
   * Get all active tasks
   */
  getAllActiveTasks(): any[] {
    const tasks = [];
    for (const [id, task] of this.activeTasks) {
      tasks.push({ taskId: id, ...task });
    }
    return tasks;
  }
}

================
File: core/logger.ts
================
/**
 * Enhanced logging system for Axiom v4
 * Provides maximum visibility into all operations
 */

import * as util from 'util';

export enum LogLevel {
  TRACE = 0,
  DEBUG = 1,
  INFO = 2,
  WARN = 3,
  ERROR = 4,
  FATAL = 5
}

export interface LogEntry {
  timestamp: string;
  level: LogLevel;
  component: string;
  method: string;
  message: string;
  data?: any;
  duration?: number;
  taskId?: string;
}

export class Logger {
  private static instance: Logger;
  private logLevel: LogLevel = LogLevel.WARN; // Default to WARN for quiet operation
  private startTimes: Map<string, number> = new Map();
  private silent: boolean = false;
  
  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
  
  private constructor() {
    // Check for env var to set log level
    const envLevel = process.env.AXIOM_LOG_LEVEL;
    if (envLevel && envLevel in LogLevel) {
      this.logLevel = LogLevel[envLevel as keyof typeof LogLevel];
    }
    
    // Check if we should be completely silent (for MCP)
    this.silent = process.env.AXIOM_SILENT === 'true' || 
                  (!process.env.AXIOM_LOG_LEVEL && !process.env.AXIOM_CONSOLE_LOG);
  }
  
  setLogLevel(level: LogLevel): void {
    this.logLevel = level;
  }
  
  private shouldLog(level: LogLevel): boolean {
    return level >= this.logLevel;
  }
  
  private formatMessage(entry: LogEntry): string {
    const level = LogLevel[entry.level];
    const time = new Date(entry.timestamp).toLocaleTimeString();
    
    // Compact, readable format
    let message = `${this.colorize(`[${level}]`, entry.level)} ${entry.message}`;
    
    // Add task ID if present
    if (entry.taskId) {
      message = `[${entry.taskId.slice(-8)}] ${message}`;
    }
    
    // Add duration if present
    if (entry.duration !== undefined) {
      message += ` ${this.colorize(`(${entry.duration}ms)`, 'duration')}`;
    }
    
    // Only show data in DEBUG or TRACE mode
    if (entry.data && this.logLevel <= LogLevel.DEBUG) {
      const dataStr = util.inspect(entry.data, { depth: 1, colors: true, compact: true });
      message += `\n  → ${dataStr}`;
    }
    
    return message;
  }
  
  private colorize(text: string, type: string | LogLevel): string {
    const colors: Record<string | number, string> = {
      [LogLevel.TRACE]: '\x1b[90m',   // Gray
      [LogLevel.DEBUG]: '\x1b[36m',   // Cyan
      [LogLevel.INFO]: '\x1b[32m',    // Green
      [LogLevel.WARN]: '\x1b[33m',    // Yellow
      [LogLevel.ERROR]: '\x1b[31m',   // Red
      [LogLevel.FATAL]: '\x1b[35m',   // Magenta
      'component': '\x1b[34m',        // Blue
      'duration': '\x1b[33m',         // Yellow
      'reset': '\x1b[0m'
    };
    
    const color = colors[type] || colors.reset;
    return `${color}${text}${colors.reset}`;
  }
  
  trace(component: string, method: string, message: string, data?: any, taskId?: string): void {
    this.log(LogLevel.TRACE, component, method, message, data, taskId);
  }
  
  debug(component: string, method: string, message: string, data?: any, taskId?: string): void {
    this.log(LogLevel.DEBUG, component, method, message, data, taskId);
  }
  
  info(component: string, method: string, message: string, data?: any, taskId?: string): void {
    this.log(LogLevel.INFO, component, method, message, data, taskId);
  }
  
  warn(component: string, method: string, message: string, data?: any, taskId?: string): void {
    this.log(LogLevel.WARN, component, method, message, data, taskId);
  }
  
  error(component: string, method: string, message: string, data?: any, taskId?: string): void {
    this.log(LogLevel.ERROR, component, method, message, data, taskId);
  }
  
  fatal(component: string, method: string, message: string, data?: any, taskId?: string): void {
    this.log(LogLevel.FATAL, component, method, message, data, taskId);
  }
  
  startTimer(key: string): void {
    this.startTimes.set(key, Date.now());
  }
  
  endTimer(key: string): number | undefined {
    const startTime = this.startTimes.get(key);
    if (startTime) {
      const duration = Date.now() - startTime;
      this.startTimes.delete(key);
      return duration;
    }
    return undefined;
  }
  
  private log(level: LogLevel, component: string, method: string, message: string, data?: any, taskId?: string): void {
    if (!this.shouldLog(level)) return;
    
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      component,
      method,
      message,
      data,
      taskId
    };
    
    // Only output if not silent
    if (!this.silent) {
      console.error(this.formatMessage(entry));
    }
  }
  
  // Special formatting for stream data
  logStream(component: string, taskId: string, data: string, metadata?: any): void {
    // Only show stream in TRACE mode
    if (!this.shouldLog(LogLevel.TRACE)) return;
    
    // Don't log empty lines
    const trimmed = data.trim();
    if (!trimmed) return;
    
    // Simple one-line format
    console.error(`${this.colorize('[STREAM]', LogLevel.TRACE)} ${trimmed}`);
    
    // Show patterns only in DEBUG mode
    if (metadata?.patterns && this.logLevel <= LogLevel.DEBUG) {
      for (const pattern of metadata.patterns) {
        console.error(`  ${this.colorize('→', LogLevel.WARN)} ${pattern} detected`);
      }
    }
  }
  
  // Log hook execution
  logHook(hookName: string, event: string, phase: 'start' | 'end', result?: any): void {
    // Only log hooks in DEBUG mode
    if (!this.shouldLog(LogLevel.DEBUG)) return;
    
    // Only log hook completions with non-continue results
    if (phase === 'end' && result?.action === 'continue') return;
    
    const icon = phase === 'start' ? '→' : '✓';
    const message = `${icon} ${hookName}: ${event}`;
    
    if (result?.action && result.action !== 'continue') {
      this.warn('Hook', hookName, `${message} [${result.action}]`, result);
    } else {
      this.debug('Hook', hookName, message);
    }
  }
  
  // Log metrics
  logMetrics(component: string, metrics: Record<string, number>): void {
    const formatted = Object.entries(metrics)
      .map(([key, value]) => `${key}=${value}`)
      .join(', ');
      
    this.info(component, 'metrics', formatted);
  }
}

================
File: core/simple-logger.ts
================
import * as fs from 'fs';
import * as path from 'path';

const logFile = path.join('/home/peter/nova-mcp/axiom-mcp/logs-v4', `debug-${Date.now()}.log`);

export function logDebug(component: string, message: string, data?: any): void {
  const timestamp = new Date().toISOString();
  const logLine = `[${timestamp}] [${component}] ${message}${data ? ' ' + JSON.stringify(data) : ''}\n`;
  
  // Write to stderr for immediate visibility
  process.stderr.write(logLine);
  
  // Append to file synchronously
  try {
    fs.appendFileSync(logFile, logLine);
  } catch (err) {
    process.stderr.write(`Failed to write to log file: ${err}\n`);
  }
}

export function getLogFile(): string {
  return logFile;
}

================
File: core/task-manager.ts
================
/**
 * Task Manager for concurrent execution tracking
 */

import { PtyExecutor } from '../executors/pty-executor.js';
import { EventEmitter } from 'events';
import { Logger } from './logger.js';

export interface TaskInfo {
  taskId: string;
  prompt: string;
  status: 'pending' | 'running' | 'completed' | 'failed' | 'interrupted';
  executor?: PtyExecutor;
  output: string;
  startTime: number;
  endTime?: number;
  parentTaskId?: string;
  childTaskIds?: string[];
  metadata?: any;
}

export class TaskManager extends EventEmitter {
  private tasks: Map<string, TaskInfo> = new Map();
  private logger = Logger.getInstance();
  
  /**
   * Create a new task
   */
  createTask(prompt: string, parentTaskId?: string): string {
    const taskId = `task-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
    
    const task: TaskInfo = {
      taskId,
      prompt,
      status: 'pending',
      output: '',
      startTime: Date.now(),
      parentTaskId
    };
    
    this.tasks.set(taskId, task);
    
    // Link to parent if exists
    if (parentTaskId) {
      const parent = this.tasks.get(parentTaskId);
      if (parent) {
        parent.childTaskIds = parent.childTaskIds || [];
        parent.childTaskIds.push(taskId);
      }
    }
    
    this.logger.info('TaskManager', 'createTask', 'Task created', { taskId, prompt: prompt.slice(0, 50) });
    this.emit('taskCreated', task);
    
    return taskId;
  }
  
  /**
   * Start executing a task
   */
  startTask(taskId: string, executor: PtyExecutor): void {
    const task = this.tasks.get(taskId);
    if (!task) {
      throw new Error(`Task ${taskId} not found`);
    }
    
    task.status = 'running';
    task.executor = executor;
    
    this.logger.info('TaskManager', 'startTask', 'Task started', { taskId });
    this.emit('taskStarted', task);
  }
  
  /**
   * Update task output
   */
  appendOutput(taskId: string, data: string): void {
    const task = this.tasks.get(taskId);
    if (!task) return;
    
    task.output += data;
    this.emit('taskOutput', { taskId, data });
  }
  
  /**
   * Complete a task
   */
  completeTask(taskId: string, output?: string): void {
    const task = this.tasks.get(taskId);
    if (!task) return;
    
    task.status = 'completed';
    task.endTime = Date.now();
    if (output !== undefined) {
      task.output = output;
    }
    
    this.logger.info('TaskManager', 'completeTask', 'Task completed', { 
      taskId, 
      duration: task.endTime - task.startTime 
    });
    this.emit('taskCompleted', task);
  }
  
  /**
   * Fail a task
   */
  failTask(taskId: string, error: string): void {
    const task = this.tasks.get(taskId);
    if (!task) return;
    
    task.status = 'failed';
    task.endTime = Date.now();
    task.metadata = { ...task.metadata, error };
    
    this.logger.error('TaskManager', 'failTask', 'Task failed', { taskId, error });
    this.emit('taskFailed', task);
  }
  
  /**
   * Interrupt a task
   */
  interruptTask(taskId: string, reason?: string): boolean {
    const task = this.tasks.get(taskId);
    if (!task || task.status !== 'running') {
      return false;
    }
    
    task.status = 'interrupted';
    task.endTime = Date.now();
    task.metadata = { ...task.metadata, interruptReason: reason };
    
    // Send interrupt to executor
    if (task.executor) {
      task.executor.interrupt();
    }
    
    this.logger.warn('TaskManager', 'interruptTask', 'Task interrupted', { taskId, reason });
    this.emit('taskInterrupted', task);
    
    return true;
  }
  
  /**
   * Get a task by ID
   */
  getTask(taskId: string): TaskInfo | undefined {
    return this.tasks.get(taskId);
  }
  
  /**
   * Get all tasks
   */
  getAllTasks(): TaskInfo[] {
    return Array.from(this.tasks.values());
  }
  
  /**
   * Get running tasks
   */
  getRunningTasks(): TaskInfo[] {
    return Array.from(this.tasks.values()).filter(t => t.status === 'running');
  }
  
  /**
   * Check if we should interrupt existing tasks for a new one
   */
  shouldInterruptFor(newPrompt: string): TaskInfo[] {
    const runningTasks = this.getRunningTasks();
    const interruptCandidates: TaskInfo[] = [];
    
    // Heuristics for when to interrupt:
    // 1. If new prompt mentions "stop" or "interrupt"
    if (newPrompt.toLowerCase().includes('stop') || 
        newPrompt.toLowerCase().includes('interrupt')) {
      return runningTasks; // Interrupt all
    }
    
    // 2. If new prompt seems to be a correction/redirect
    const correctionKeywords = ['no', 'wait', 'actually', 'instead', 'don\'t'];
    const hasCorrection = correctionKeywords.some(kw => 
      newPrompt.toLowerCase().startsWith(kw)
    );
    
    if (hasCorrection && runningTasks.length > 0) {
      // Interrupt the most recent task
      return [runningTasks[runningTasks.length - 1]];
    }
    
    // 3. If running task is in "planning" mode for too long
    const now = Date.now();
    for (const task of runningTasks) {
      const runtime = now - task.startTime;
      const hasPlanning = task.output.toLowerCase().includes('analyze') ||
                         task.output.toLowerCase().includes('approach') ||
                         task.output.toLowerCase().includes('consider');
      
      if (runtime > 10000 && hasPlanning && !task.output.includes('File created')) {
        interruptCandidates.push(task);
      }
    }
    
    return interruptCandidates;
  }
  
  /**
   * Clean up completed tasks older than specified age
   */
  cleanup(maxAge: number = 3600000): void { // Default 1 hour
    const now = Date.now();
    const toDelete: string[] = [];
    
    for (const [taskId, task] of this.tasks) {
      if (task.endTime && (now - task.endTime) > maxAge) {
        toDelete.push(taskId);
      }
    }
    
    for (const taskId of toDelete) {
      this.tasks.delete(taskId);
    }
    
    if (toDelete.length > 0) {
      this.logger.debug('TaskManager', 'cleanup', `Removed ${toDelete.length} old tasks`);
    }
  }
  
  /**
   * Get task hierarchy (for parallel execution)
   */
  getTaskHierarchy(parentTaskId: string): TaskInfo[] {
    const parent = this.tasks.get(parentTaskId);
    if (!parent || !parent.childTaskIds) {
      return [];
    }
    
    return parent.childTaskIds
      .map(id => this.tasks.get(id))
      .filter(task => task !== undefined) as TaskInfo[];
  }
  
  /**
   * Format task for display
   */
  formatTask(taskId: string): string {
    const task = this.tasks.get(taskId);
    if (!task) return `Task ${taskId} not found`;
    
    const runtime = task.endTime 
      ? `${task.endTime - task.startTime}ms`
      : `${Date.now() - task.startTime}ms (running)`;
    
    return `[${taskId}] ${task.status.toUpperCase()} - ${task.prompt.slice(0, 50)}... (${runtime})`;
  }
}

// Singleton instance
export const taskManager = new TaskManager();

================
File: database/conversation-db.ts
================
import sqlite3 from 'sqlite3';
import { promisify } from 'util';
import * as path from 'path';
import * as fs from 'fs/promises';
import { HookEvent } from '../core/hook-orchestrator.js';

// Type-safe promisified sqlite3 methods
type RunFunction = (sql: string, params?: any[]) => Promise<void>;
type GetFunction = (sql: string, params?: any[]) => Promise<any>;
type AllFunction = (sql: string, params?: any[]) => Promise<any[]>;

export interface Conversation {
  id: string;
  parent_id?: string;
  started_at: string;
  status: 'active' | 'completed' | 'failed';
  depth: number;
  prompt: string;
  task_type: string;
  metadata?: Record<string, any>;
}

export interface Action {
  id: string;
  conversation_id: string;
  timestamp: string;
  type: 'file_created' | 'file_modified' | 'command_executed' | 'error' | 'error_occurred' | 'output' | 'task_started' | 'task_completed' | 'code_block' | 'output_chunk' | 'intervention';
  content: string;
  metadata?: Record<string, any>;
}

export interface Stream {
  id: string;
  conversation_id: string;
  chunk: string;
  parsed_data?: Record<string, any>;
  timestamp: string;
}

export interface ObservationView {
  id: string;
  name: string;
  filter_json: string;
  created_at: string;
}

export class ConversationDB {
  private db!: sqlite3.Database;
  private dbPath: string;
  private hookOrchestrator?: any; // Will be injected
  
  constructor(dbPath?: string) {
    // Use environment variable or fallback to temp directory
    const defaultPath = process.env.AXIOM_DB_PATH || 
                       path.join(process.env.HOME || process.env.USERPROFILE || '/tmp', '.axiom-mcp', 'axiom-v4.db');
    this.dbPath = dbPath || defaultPath;
  }
  
  // v4 addition: Set hook orchestrator for DB events
  setHookOrchestrator(orchestrator: any): void {
    this.hookOrchestrator = orchestrator;
  }
  
  async initialize(): Promise<void> {
    // Ensure directory exists
    await fs.mkdir(path.dirname(this.dbPath), { recursive: true });
    
    return new Promise((resolve, reject) => {
      this.db = new sqlite3.Database(this.dbPath, (err) => {
        if (err) reject(err);
        else {
          this.db.run('PRAGMA journal_mode = WAL');
          this.db.run('PRAGMA foreign_keys = ON');
          this.createTables().then(resolve).catch(reject);
        }
      });
    });
  }
  
  private async createTables(): Promise<void> {
    const run = promisify(this.db.run.bind(this.db)) as RunFunction;
    
    // Create conversations table
    await run(`
      CREATE TABLE IF NOT EXISTS conversations (
        id TEXT PRIMARY KEY,
        parent_id TEXT,
        started_at TEXT NOT NULL,
        status TEXT NOT NULL,
        depth INTEGER NOT NULL,
        prompt TEXT NOT NULL,
        task_type TEXT NOT NULL,
        metadata TEXT,
        FOREIGN KEY (parent_id) REFERENCES conversations(id)
      )
    `);
    
    // Create actions table
    await run(`
      CREATE TABLE IF NOT EXISTS actions (
        id TEXT PRIMARY KEY,
        conversation_id TEXT NOT NULL,
        timestamp TEXT NOT NULL,
        type TEXT NOT NULL,
        content TEXT NOT NULL,
        metadata TEXT,
        FOREIGN KEY (conversation_id) REFERENCES conversations(id)
      )
    `);
    
    // Create streams table
    await run(`
      CREATE TABLE IF NOT EXISTS streams (
        id TEXT PRIMARY KEY,
        conversation_id TEXT NOT NULL,
        chunk TEXT NOT NULL,
        parsed_data TEXT,
        timestamp TEXT NOT NULL,
        FOREIGN KEY (conversation_id) REFERENCES conversations(id)
      )
    `);
    
    // Create observation views table
    await run(`
      CREATE TABLE IF NOT EXISTS observation_views (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        filter_json TEXT NOT NULL,
        created_at TEXT NOT NULL
      )
    `);
    
    // Create indexes
    await run('CREATE INDEX IF NOT EXISTS idx_actions_conversation ON actions(conversation_id)');
    await run('CREATE INDEX IF NOT EXISTS idx_streams_conversation ON streams(conversation_id)');
    await run('CREATE INDEX IF NOT EXISTS idx_conversations_parent ON conversations(parent_id)');
  }
  
  async createConversation(conversation: Omit<Conversation, 'id'>): Promise<Conversation> {
    const id = `conv-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const conv = { ...conversation, id };
    
    const run = promisify(this.db.run.bind(this.db)) as RunFunction;
    await run(
      `INSERT INTO conversations (id, parent_id, started_at, status, depth, prompt, task_type, metadata) 
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, conv.parent_id, conv.started_at, conv.status, conv.depth, conv.prompt, conv.task_type, 
       conv.metadata ? JSON.stringify(conv.metadata) : null]
    );
    
    // v4: Notify hooks of new conversation
    if (this.hookOrchestrator) {
      await this.hookOrchestrator.triggerHooks('DATABASE_CONVERSATION_CREATED', { conversation: conv });
    }
    
    return conv;
  }
  
  async updateConversation(id: string, updates: Partial<Conversation>): Promise<void> {
    const run = promisify(this.db.run.bind(this.db)) as RunFunction;
    const fields = Object.keys(updates).filter(k => k !== 'id');
    const values = fields.map(f => f === 'metadata' ? JSON.stringify(updates[f as keyof Conversation]) : updates[f as keyof Conversation]);
    
    if (fields.length === 0) return;
    
    const sql = `UPDATE conversations SET ${fields.map(f => `${f} = ?`).join(', ')} WHERE id = ?`;
    await run(sql, [...values, id]);
    
    // v4: Notify hooks of conversation update
    if (this.hookOrchestrator) {
      await this.hookOrchestrator.triggerHooks('DATABASE_CONVERSATION_UPDATED', { id, updates });
    }
  }
  
  async logAction(action: Omit<Action, 'id'>): Promise<Action> {
    const id = `action-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const act = { ...action, id };
    
    const run = promisify(this.db.run.bind(this.db)) as RunFunction;
    await run(
      `INSERT INTO actions (id, conversation_id, timestamp, type, content, metadata) 
       VALUES (?, ?, ?, ?, ?, ?)`,
      [id, act.conversation_id, act.timestamp, act.type, act.content, 
       act.metadata ? JSON.stringify(act.metadata) : null]
    );
    
    // v4: Notify hooks of new action
    if (this.hookOrchestrator) {
      await this.hookOrchestrator.triggerHooks('DATABASE_ACTION_LOGGED', { action: act });
    }
    
    return act;
  }
  
  async logStream(stream: Omit<Stream, 'id'>): Promise<Stream> {
    const id = `stream-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const str = { ...stream, id };
    
    const run = promisify(this.db.run.bind(this.db)) as RunFunction;
    await run(
      `INSERT INTO streams (id, conversation_id, chunk, parsed_data, timestamp) 
       VALUES (?, ?, ?, ?, ?)`,
      [id, str.conversation_id, str.chunk, 
       str.parsed_data ? JSON.stringify(str.parsed_data) : null, str.timestamp]
    );
    
    return str;
  }
  
  async getConversation(id: string): Promise<Conversation | null> {
    const get = promisify(this.db.get.bind(this.db)) as GetFunction;
    const row = await get('SELECT * FROM conversations WHERE id = ?', [id]);
    
    if (!row) return null;
    
    return {
      ...row,
      metadata: row.metadata ? JSON.parse(row.metadata) : undefined
    };
  }
  
  async getActiveConversations(): Promise<Conversation[]> {
    const all = promisify(this.db.all.bind(this.db)) as AllFunction;
    const rows = await all(
      'SELECT * FROM conversations WHERE status = ? ORDER BY started_at DESC',
      ['active']
    );
    
    return rows.map((row: any) => ({
      ...row,
      metadata: row.metadata ? JSON.parse(row.metadata) : undefined
    }));
  }
  
  async getConversationTree(rootId: string): Promise<Conversation[]> {
    const all = promisify(this.db.all.bind(this.db)) as AllFunction;
    const conversations: Conversation[] = [];
    
    const visit = async (id: string) => {
      const row = await this.getConversation(id);
      if (row) {
        conversations.push(row);
        const children = await all(
          'SELECT * FROM conversations WHERE parent_id = ? ORDER BY started_at',
          [id]
        );
        for (const child of children) {
          await visit(child.id);
        }
      }
    };
    
    await visit(rootId);
    return conversations;
  }
  
  async getRecentActions(limit: number = 10): Promise<Action[]> {
    const all = promisify(this.db.all.bind(this.db)) as AllFunction;
    const rows = await all(
      'SELECT * FROM actions ORDER BY timestamp DESC LIMIT ?',
      [limit]
    );
    
    return rows.map((row: any) => ({
      ...row,
      metadata: row.metadata ? JSON.parse(row.metadata) : undefined
    }));
  }
  
  async getStats(): Promise<any> {
    const get = promisify(this.db.get.bind(this.db)) as GetFunction;
    const all = promisify(this.db.all.bind(this.db)) as AllFunction;
    
    const totalConversations = await get('SELECT COUNT(*) as count FROM conversations');
    const activeConversations = await get('SELECT COUNT(*) as count FROM conversations WHERE status = ?', ['active']);
    const completedConversations = await get('SELECT COUNT(*) as count FROM conversations WHERE status = ?', ['completed']);
    const failedConversations = await get('SELECT COUNT(*) as count FROM conversations WHERE status = ?', ['failed']);
    
    const actionsByType = await all(
      'SELECT type, COUNT(*) as count FROM actions GROUP BY type'
    );
    
    const violationsByType = await all(
      `SELECT 
         CASE 
           WHEN content LIKE '%TODO%' THEN 'todo_violation'
           WHEN content LIKE '%mock%' THEN 'mock_violation'
           WHEN type = 'error' THEN 'error'
           ELSE 'other'
         END as violation_type,
         COUNT(*) as count
       FROM actions 
       WHERE type IN ('error', 'intervention')
       GROUP BY violation_type`
    );
    
    return {
      totalConversations: totalConversations.count,
      activeConversations: activeConversations.count,
      completedConversations: completedConversations.count,
      failedConversations: failedConversations.count,
      actionsByType: Object.fromEntries(actionsByType.map((r: any) => [r.type, r.count])),
      violationsByType: Object.fromEntries(violationsByType.map((r: any) => [r.violation_type, r.count]))
    };
  }
  
  async close(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.db.close((err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }
}

================
File: executors/claude-session-manager.ts
================
/**
 * Claude Session Manager - Manages interactive Claude sessions
 * The entire point: bidirectional communication with running Claude
 */

import { EventEmitter } from 'events';
import * as pty from 'node-pty';
import { Logger } from '../core/logger.js';
import { logDebug } from '../core/simple-logger.js';

export interface ClaudeSession {
  id: string;
  pty: pty.IPty;
  output: string;
  ready: boolean;
  busy: boolean;
  created: Date;
}

export class ClaudeSessionManager extends EventEmitter {
  private sessions: Map<string, ClaudeSession> = new Map();
  private logger: Logger;
  
  constructor() {
    super();
    this.logger = Logger.getInstance();
  }
  
  /**
   * Create a new Claude session
   */
  async createSession(sessionId: string): Promise<ClaudeSession> {
    logDebug('SESSION', `Creating new Claude session: ${sessionId}`);
    
    // Spawn PTY with Claude
    const ptyProcess = pty.spawn('claude', [], {
      name: 'xterm-color',
      cols: 120,
      rows: 30,
      cwd: process.cwd(),
      env: process.env as any
    });
    
    const session: ClaudeSession = {
      id: sessionId,
      pty: ptyProcess,
      output: '',
      ready: false,
      busy: false,
      created: new Date()
    };
    
    // Handle output
    ptyProcess.onData((data: string) => {
      session.output += data;
      logDebug('SESSION', `Data received (${data.length} bytes): ${data.slice(0, 50).replace(/\n/g, '\\n')}`);
      
      // Detect when Claude is ready for input
      // Look for Claude's actual interactive prompt
      // Claude shows "To test the Axiom MCP" or similar introductory text
      // followed by blank lines when ready
      if (!session.ready) {
        // Check for common Claude interactive mode patterns
        const lowerData = data.toLowerCase();
        if (lowerData.includes('would you like') || 
            lowerData.includes('how can i help') ||
            lowerData.includes('to test') ||
            lowerData.includes('grant') ||
            data.includes('```') ||
            (session.output.length > 100 && data.trim() === '')) {
          session.ready = true;
          session.busy = false;
          logDebug('SESSION', `Session ${sessionId} is ready (detected interactive prompt)`);
          this.emit('ready', sessionId);
        }
      }
      
      // Detect when Claude is working
      // Look for common working indicators
      if (data.includes('Thinking') || 
          data.includes('Working') ||
          data.includes('Creating') ||
          data.includes('Writing') ||
          data.includes('Implementing') ||
          data.includes('...')) {
        session.busy = true;
        logDebug('SESSION', `Session ${sessionId} is busy`);
      }
      
      // Detect when Claude finishes
      // Look for completion patterns
      if (session.busy && (
          data.includes('Created') ||
          data.includes('Finished') ||
          data.includes('Complete') ||
          data.includes('Done') ||
          (data.trim() === '' && session.output.includes('\n\n')))) {
        session.busy = false;
        logDebug('SESSION', `Session ${sessionId} finished work`);
      }
      
      // Emit data for streaming
      this.emit('data', sessionId, data);
    });
    
    // Handle exit
    ptyProcess.onExit((exitCode) => {
      logDebug('SESSION', `Session ${sessionId} exited with code ${exitCode.exitCode}`);
      this.sessions.delete(sessionId);
      this.emit('exit', sessionId, exitCode.exitCode);
    });
    
    this.sessions.set(sessionId, session);
    
    // Wait for ready
    await this.waitForReady(sessionId);
    
    return session;
  }
  
  /**
   * Send a message to a session
   */
  async sendMessage(sessionId: string, message: string): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (!session) {
      throw new Error(`Session ${sessionId} not found`);
    }
    
    if (!session.ready) {
      throw new Error(`Session ${sessionId} not ready`);
    }
    
    logDebug('SESSION', `Sending message to ${sessionId}: ${message}`);
    
    // In Claude's UI, we type the message and press Enter
    session.pty.write(message + '\n');
    
    // If Claude is already working, this becomes an interruption
    if (session.busy) {
      logDebug('SESSION', `Message sent while Claude is busy - this is an intervention!`);
      this.emit('intervention', sessionId, message);
    }
  }
  
  /**
   * Wait for session to be ready
   */
  private waitForReady(sessionId: string, timeout = 10000): Promise<void> {
    return new Promise((resolve, reject) => {
      const session = this.sessions.get(sessionId);
      if (!session) {
        reject(new Error(`Session ${sessionId} not found`));
        return;
      }
      
      if (session.ready) {
        resolve();
        return;
      }
      
      const timer = setTimeout(() => {
        reject(new Error(`Session ${sessionId} ready timeout`));
      }, timeout);
      
      const readyHandler = (readyId: string) => {
        if (readyId === sessionId) {
          clearTimeout(timer);
          this.removeListener('ready', readyHandler);
          resolve();
        }
      };
      
      this.on('ready', readyHandler);
    });
  }
  
  /**
   * Get session output
   */
  getOutput(sessionId: string): string {
    const session = this.sessions.get(sessionId);
    return session ? session.output : '';
  }
  
  /**
   * Kill a session
   */
  killSession(sessionId: string): void {
    const session = this.sessions.get(sessionId);
    if (session) {
      logDebug('SESSION', `Killing session ${sessionId}`);
      session.pty.kill();
      this.sessions.delete(sessionId);
    }
  }
  
  /**
   * Get all active sessions
   */
  getActiveSessions(): string[] {
    return Array.from(this.sessions.keys());
  }
}

================
File: executors/command-executor.ts
================
import { spawn, IPty } from 'node-pty';
import { EventEmitter } from 'events';
import * as os from 'os';
import { HookOrchestrator, HookEvent } from '../core/hook-orchestrator.js';
import { Logger } from '../core/logger.js';
import { logDebug } from '../core/simple-logger.js';

const logger = Logger.getInstance();

export interface ExecutorOptions {
  shell?: string;
  cwd?: string;
  env?: Record<string, string>;
  enableMonitoring?: boolean;
  hookOrchestrator?: HookOrchestrator;
}

/**
 * CommandExecutor - Executes actual commands instead of calling Claude recursively
 */
export class CommandExecutor extends EventEmitter {
  private pty?: IPty;
  private output: string = '';
  private isComplete: boolean = false;
  private hookOrchestrator?: HookOrchestrator;
  
  constructor(private options: ExecutorOptions = {}) {
    super();
    this.hookOrchestrator = options.hookOrchestrator;
  }
  
  async execute(
    prompt: string, 
    systemPrompt: string,
    taskId: string,
    streamHandler?: (data: string) => void
  ): Promise<string> {
    logDebug('CMD_EXECUTOR', 'Starting execution', { taskId, prompt });
    
    return new Promise((resolve, reject) => {
      const shell = this.options.shell || (os.platform() === 'win32' ? 'powershell.exe' : 'bash');
      const cwd = this.options.cwd || process.cwd();
      
      // Create PTY instance
      this.pty = spawn(shell, [], {
        name: 'xterm-color',
        cols: 120,
        rows: 30,
        cwd,
        env: {
          ...process.env,
          ...this.options.env,
          FORCE_COLOR: '0',
        } as any
      });
      
      // Handle data
      this.pty.onData(async (data: string) => {
        logDebug('CMD_EXECUTOR', `Received ${data.length} bytes`);
        this.output += data;
        
        if (streamHandler) {
          streamHandler(data);
        }
        
        this.emit('data', data);
      });
      
      // Handle exit
      this.pty.onExit((exitCode) => {
        logDebug('CMD_EXECUTOR', 'Process exited', { exitCode: exitCode.exitCode });
        this.isComplete = true;
        
        if (exitCode.exitCode === 0) {
          resolve(this.output);
        } else {
          reject(new Error(`Process exited with code ${exitCode.exitCode}`));
        }
      });
      
      // Parse the prompt and execute actual commands
      this.executePrompt(prompt, taskId);
    });
  }
  
  private executePrompt(prompt: string, taskId: string): void {
    logDebug('CMD_EXECUTOR', 'Parsing prompt', { prompt });
    
    // Simple prompt parsing - look for file creation requests
    if (prompt.toLowerCase().includes('create') && prompt.includes('.py')) {
      // Extract filename
      const fileMatch = prompt.match(/(\w+\.py)/);
      if (fileMatch) {
        const filename = fileMatch[1];
        logDebug('CMD_EXECUTOR', `Creating Python file: ${filename}`);
        
        // Create the file
        if (prompt.toLowerCase().includes('hello') || prompt.toLowerCase().includes('print')) {
          this.pty!.write(`cat > ${filename} << 'EOF'\nprint('Hello World')\nEOF\n`);
        } else {
          this.pty!.write(`cat > ${filename} << 'EOF'\n# ${prompt}\n# TODO: Implement\nprint('Not implemented yet')\nEOF\n`);
        }
        
        // Confirm creation
        setTimeout(() => {
          if (this.pty) {
            this.pty.write(`echo "Created file: ${filename}"\n`);
            this.pty.write(`ls -la ${filename}\n`);
            setTimeout(() => {
              if (this.pty) this.pty.write('exit\n');
            }, 500);
          }
        }, 500);
        
        return;
      }
    }
    
    // Default: just echo the prompt
    this.pty!.write(`echo "Task: ${prompt}"\n`);
    setTimeout(() => {
      if (this.pty) this.pty.write('exit\n');
    }, 1000);
  }
  
  kill(): void {
    if (this.pty) {
      this.pty.kill();
      this.isComplete = true;
    }
  }
  
  getOutput(): string {
    return this.output;
  }
  
  isRunning(): boolean {
    return !this.isComplete && this.pty !== undefined;
  }
}

================
File: executors/pty-executor.ts
================
import { spawn, IPty } from 'node-pty';
import { EventEmitter } from 'events';
import * as os from 'os';
import { HookOrchestrator, HookEvent } from '../core/hook-orchestrator.js';
import { Logger } from '../core/logger.js';
import { logDebug } from '../core/simple-logger.js';

const logger = Logger.getInstance();

export interface ExecutorOptions {
  shell?: string;
  cwd?: string;
  env?: Record<string, string>;
  enableMonitoring?: boolean;
  hookOrchestrator?: HookOrchestrator;
}

export class PtyExecutor extends EventEmitter {
  private pty?: IPty;
  private output: string = '';
  private isComplete: boolean = false;
  private interventionQueue: string[] = [];
  private hookOrchestrator?: HookOrchestrator;
  
  constructor(private options: ExecutorOptions = {}) {
    super();
    this.hookOrchestrator = options.hookOrchestrator;
  }
  
  async execute(
    prompt: string, 
    systemPrompt: string,
    taskId: string,
    streamHandler?: (data: string) => void
  ): Promise<string> {
    logger.info('PtyExecutor', 'execute', 'Starting execution', { 
      taskId, 
      promptLength: prompt.length,
      hasStreamHandler: !!streamHandler 
    });
    
    return new Promise((resolve, reject) => {
      const shell = this.options.shell || (os.platform() === 'win32' ? 'powershell.exe' : 'bash');
      const cwd = this.options.cwd || process.cwd();
      
      logger.debug('PtyExecutor', 'execute', 'Creating PTY instance', { shell, cwd });
      
      // Create PTY instance
      logDebug('PTY', 'About to spawn PTY', { 
        shell, 
        cwd,
        envKeys: Object.keys({...process.env, ...this.options.env})
      });
      
      try {
        this.pty = spawn(shell, [], {
          name: 'xterm-color',
          cols: 120,
          rows: 30,
          cwd,
          env: {
            ...process.env,
            ...this.options.env,
            FORCE_COLOR: '0', // Disable ANSI colors
            PROMPT: prompt,
            SYSTEM_PROMPT: systemPrompt,
            TASK_ID: taskId
          } as any
        });
        
        logDebug('PTY', 'PTY spawned successfully', { 
          pid: this.pty.pid,
          process: this.pty.process
        });
      } catch (error) {
        logDebug('PTY', 'FAILED to spawn PTY', { 
          error: error instanceof Error ? error.message : error,
          stack: error instanceof Error ? error.stack : undefined
        });
        reject(error);
        return;
      }
      
      logger.info('PtyExecutor', 'execute', 'PTY created, setting up handlers', { taskId });
      
      // Verify PTY is really alive
      logDebug('PTY', 'Verifying PTY is alive', {
        pid: this.pty.pid,
        cols: this.pty.cols,
        rows: this.pty.rows
      });
      
      // Setup onData handler first
      logDebug('PTY', 'Setting up onData handler');
      let dataHandlerSet = false;
      
      // Handle data with hook integration
      this.pty.onData(async (data: string) => {
        if (!dataHandlerSet) {
          dataHandlerSet = true;
          logDebug('PTY', 'First onData event received!');
        }
        
        logDebug('PTY', `onData called - received ${data.length} bytes`, {
          taskId,
          preview: data.slice(0, 200).replace(/\n/g, '\\n').replace(/\r/g, '\\r')
        });
        
        logger.trace('PtyExecutor', 'onData', 'Received data', { 
          taskId,
          dataLength: data.length,
          preview: data.slice(0, 100).replace(/\n/g, '\\n')
        });
        
        this.output += data;
        
        // v4: Process stream through hooks
        if (this.hookOrchestrator) {
          const result = await this.hookOrchestrator.triggerHooks(HookEvent.EXECUTION_STREAM, {
            stream: { data, source: taskId },
            execution: { taskId, status: 'running' }
          });
          
          // Check for interventions
          if (result.modifications?.command) {
            this.injectCommand(result.modifications.command);
          }
        }
        
        // Call stream handler
        if (streamHandler) {
          streamHandler(data);
        }
        
        // Emit for other listeners
        this.emit('data', data);
        
        // Check for process idle
        this.resetIdleTimer();
      });
      
      // Handle exit
      logDebug('PTY', 'Setting up onExit handler');
      this.pty.onExit((exitCode) => {
        logDebug('PTY', 'onExit triggered', { exitCode });
        logger.info('PtyExecutor', 'onExit', 'PTY process exited', { 
          taskId,
          exitCode: exitCode.exitCode,
          outputLength: this.output.length 
        });
        
        this.isComplete = true;
        
        if (exitCode.exitCode === 0) {
          resolve(this.output);
        } else {
          reject(new Error(`Process exited with code ${exitCode.exitCode}`));
        }
      });
      
      // v4: Notify hooks of execution start
      if (this.hookOrchestrator) {
        logger.debug('PtyExecutor', 'execute', 'Triggering execution started hooks', { taskId });
        this.hookOrchestrator.triggerHooks(HookEvent.EXECUTION_STARTED, {
          execution: { taskId, status: 'running' },
          request: { tool: 'pty_executor', args: { prompt, systemPrompt } }
        });
      }
      
      // Start claude in interactive mode
      const claudeCommand = `claude\n`;
      
      logger.info('PtyExecutor', 'execute', 'Starting interactive Claude', { 
        taskId,
        prompt: prompt.slice(0, 100)
      });
      
      logDebug('PTY', 'Starting Claude interactive session', {
        ptyPid: this.pty.pid
      });
      
      // Start Claude
      this.pty.write(claudeCommand);
      
      // Wait for Claude to start, then send the prompt
      setTimeout(() => {
        logDebug('PTY', 'Sending prompt to Claude', {
          prompt: prompt.slice(0, 100)
        });
        if (this.pty) this.pty.write(prompt + '\n');
      }, 1000);
      
      logDebug('PTY', 'Commands queued for execution');
      
      logger.debug('PtyExecutor', 'execute', 'Command written, starting heartbeat', { taskId });
      
      // Send heartbeat to prevent hanging
      this.startHeartbeat();
      
      // Add early detection of no output
      setTimeout(() => {
        if (this.output.length === 0) {
          logDebug('PTY', 'WARNING: No output after 2s - checking PTY status');
          if (this.pty) this.pty.write('echo "PTY alive"\n');
        }
      }, 2000);
      
      setTimeout(() => {
        if (this.output.length === 0) {
          logDebug('PTY', 'ERROR: No output after 5s - PTY may be stuck', {
            taskId,
            isComplete: this.isComplete
          });
          // Try to get some output
          if (this.pty) this.pty.write('echo "PTY TEST"\n');
        }
      }, 5000);
    });
  }
  
  private idleTimer?: NodeJS.Timeout;
  private resetIdleTimer(): void {
    if (this.idleTimer) {
      clearTimeout(this.idleTimer);
    }
    
    // Consider process idle after 30 seconds of no output
    this.idleTimer = setTimeout(() => {
      if (!this.isComplete) {
        logger.warn('PtyExecutor', 'checkIdleTimeout', 'Process appears idle, sending interrupt');
        logDebug('PTY', 'IDLE TIMEOUT - Process hasn\'t produced output for 30s, interrupting');
        this.interrupt();
      }
    }, 30000);
  }
  
  private heartbeat?: NodeJS.Timeout;
  private startHeartbeat(): void {
    logDebug('PTY', 'Starting heartbeat timer (10s intervals)');
    let heartbeatCount = 0;
    // Send periodic newline to keep PTY alive
    this.heartbeat = setInterval(() => {
      heartbeatCount++;
      if (!this.isComplete && this.pty) {
        logDebug('PTY', `Heartbeat #${heartbeatCount} - sending newline to keep PTY alive`, {
          isComplete: this.isComplete,
          ptyPid: this.pty.pid,
          outputLength: this.output.length,
          outputPreview: this.output.slice(-100)
        });
        this.pty.write('\n');
      } else {
        logDebug('PTY', `Heartbeat #${heartbeatCount} - skipped`, {
          isComplete: this.isComplete,
          hasPty: !!this.pty
        });
      }
    }, 10000);
  }
  
  injectCommand(command: string): void {
    if (this.pty && !this.isComplete) {
      logger.info('PtyExecutor', 'injectCommand', `Injecting command: ${command.trim()}`);
      this.pty.write(command);
      
      // v4: Log intervention
      if (this.hookOrchestrator) {
        this.hookOrchestrator.triggerHooks(HookEvent.EXECUTION_INTERVENTION, {
          execution: { taskId: 'current', status: 'running' },
          metadata: { command }
        });
      }
    }
  }
  
  write(data: string): void {
    if (this.pty && !this.isComplete) {
      this.pty.write(data);
    }
  }
  
  interrupt(): void {
    if (this.pty && !this.isComplete) {
      this.pty.write('\x03'); // Ctrl+C
    }
  }
  
  kill(): void {
    if (this.heartbeat) {
      clearInterval(this.heartbeat);
    }
    
    if (this.idleTimer) {
      clearTimeout(this.idleTimer);
    }
    
    if (this.pty) {
      this.pty.kill();
      this.isComplete = true;
    }
  }
  
  getOutput(): string {
    return this.output;
  }
  
  isRunning(): boolean {
    return !this.isComplete && this.pty !== undefined;
  }
}

================
File: executors/session-based-executor.ts
================
/**
 * Session-Based Executor - Uses Claude Session Manager
 * This is what makes bidirectional communication possible
 */

import { EventEmitter } from 'events';
import { Logger } from '../core/logger.js';
import { ClaudeSessionManager } from './claude-session-manager.js';
import { HookOrchestrator } from '../core/hook-orchestrator.js';

export class SessionBasedExecutor extends EventEmitter {
  private sessionManager: ClaudeSessionManager;
  private hookOrchestrator?: HookOrchestrator;
  private logger: Logger;
  private currentTaskId?: string;
  
  constructor(options: { hookOrchestrator?: HookOrchestrator } = {}) {
    super();
    this.sessionManager = new ClaudeSessionManager();
    this.hookOrchestrator = options.hookOrchestrator;
    this.logger = Logger.getInstance();
  }
  
  async execute(
    prompt: string,
    systemPrompt: string,
    taskId: string,
    streamHandler?: (data: string) => void
  ): Promise<string> {
    
    this.logger.info('SessionBasedExecutor', 'execute', 'Starting execution', { taskId, prompt });
    
    // Track current task
    this.currentTaskId = taskId;
    
    // Create a session for this task
    const session = await this.sessionManager.createSession(taskId);
    
    // Set up streaming
    this.sessionManager.on('data', (sessionId, data) => {
      if (sessionId === taskId) {
        if (streamHandler) streamHandler(data);
        this.emit('data', data);
      }
    });
    
    // Send the initial prompt
    await this.sessionManager.sendMessage(taskId, prompt);
    
    // In verbose mode, we return immediately
    // The session continues running and can receive more messages
    return new Promise((resolve) => {
      // For now, just track that we started
      // Real implementation would track completion
      this.sessionManager.on('exit', (sessionId, code) => {
        if (sessionId === taskId) {
          resolve(this.sessionManager.getOutput(taskId));
        }
      });
    });
  }
  
  /**
   * Send a message to the running session
   * THIS is the key - we can send messages while Claude is working!
   */
  async write(message: string): Promise<void> {
    // Use the current task ID if available
    const taskId = this.currentTaskId || this.sessionManager.getActiveSessions()[0];
    
    if (!taskId) {
      this.logger.warn('SessionBasedExecutor', 'write', 'No active session to write to');
      return;
    }
    
    try {
      await this.sessionManager.sendMessage(taskId, message);
      this.logger.info('SessionBasedExecutor', 'write', 'Sent intervention', { taskId, message });
    } catch (error) {
      this.logger.error('SessionBasedExecutor', 'write', 'Failed to send message', { error });
    }
  }
  
  interrupt(): void {
    // With sessions, interrupt is just sending a message!
    this.write('[INTERRUPT] Stop and listen to new instructions');
  }
  
  kill(): void {
    // Kill all sessions
    const sessions = this.sessionManager.getActiveSessions();
    sessions.forEach(id => this.sessionManager.killSession(id));
  }
}

================
File: executors/simple-executor.ts
================
/**
 * Simple executor for testing - simulates Claude execution
 */

import { EventEmitter } from 'events';
import { exec } from 'child_process';
import { Logger } from '../core/logger.js';
import { HookOrchestrator } from '../core/hook-orchestrator.js';
import { HookEvent } from '../core/hook-orchestrator.js';

export class SimpleExecutor extends EventEmitter {
  private hookOrchestrator?: HookOrchestrator;
  private logger: Logger;
  private currentLanguage: string = '';
  private interventionReceived: boolean = false;
  
  constructor(options: { hookOrchestrator?: HookOrchestrator } = {}) {
    super();
    this.hookOrchestrator = options.hookOrchestrator;
    this.logger = Logger.getInstance();
  }
  
  async execute(
    prompt: string,
    systemPrompt: string,
    taskId: string,
    streamHandler?: (data: string) => void
  ): Promise<string> {
    
    this.logger.info('SimpleExecutor', 'execute', 'Starting execution', { taskId, prompt });
    
    // Simulate Claude starting
    const stream = (data: string) => {
      if (streamHandler) streamHandler(data);
      this.emit('data', data);
    };
    
    stream('Starting task execution...\n');
    
    // Simulate some work
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    stream(`Processing: ${prompt}\n`);
    
    // Determine initial language
    if (prompt.toLowerCase().includes('python')) {
      this.currentLanguage = 'python';
    } else if (prompt.toLowerCase().includes('java')) {
      this.currentLanguage = 'java';
    }
    
    // Simulate thinking time where intervention can happen
    stream('Thinking about the task...\n');
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    // Check if intervention changed the language
    const targetLanguage = this.interventionReceived ? this.currentLanguage : 
                          (prompt.toLowerCase().includes('python') ? 'python' : 
                           prompt.toLowerCase().includes('java') ? 'java' : 'generic');
    
    if (targetLanguage === 'python') {
      stream('Creating Python file...\n');
      
      const code = `# Fibonacci function
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# Test
for i in range(10):
    print(f"fib({i}) = {fibonacci(i)}")
`;
      
      await import('fs').then(fs => fs.writeFileSync('fibonacci.py', code));
      stream('Created file: fibonacci.py\n');
      stream('Contents:\n' + code);
      
      return 'Task completed: Created fibonacci.py';
    } else if (targetLanguage === 'java') {
      stream('Creating Java file...\n');
      
      const code = `public class Fibonacci {
    public static int fibonacci(int n) {
        if (n <= 1) return n;
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
    
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            System.out.println("fib(" + i + ") = " + fibonacci(i));
        }
    }
}
`;
      
      await import('fs').then(fs => fs.writeFileSync('Hello.java', code));
      stream('Created file: Hello.java\n');
      stream('Contents:\n' + code);
      
      return 'Task completed: Created Hello.java';
    } else {
      stream('Executing generic task...\n');
      return 'Task completed';
    }
  }
  
  write(message: string): void {
    this.logger.info('SimpleExecutor', 'write', 'Received message', { message });
    this.emit('data', `[USER INPUT]: ${message}\n`);
    
    // Check if this is a language change intervention
    if (message.toLowerCase().includes('java')) {
      this.currentLanguage = 'java';
      this.interventionReceived = true;
      this.emit('data', '[INTERVENTION ACCEPTED]: Switching to Java\n');
    } else if (message.toLowerCase().includes('python')) {
      this.currentLanguage = 'python';
      this.interventionReceived = true;
      this.emit('data', '[INTERVENTION ACCEPTED]: Switching to Python\n');
    }
  }
  
  interrupt(): void {
    this.logger.info('SimpleExecutor', 'interrupt', 'Interrupted');
    this.emit('data', '[INTERRUPTED]\n');
  }
  
  kill(): void {
    this.logger.info('SimpleExecutor', 'kill', 'Killed');
  }
}

================
File: hooks/conversation-db.ts
================
/**
 * Minimal ConversationDB interface for v4 hooks
 */

export interface ConversationDB {
  init(): Promise<void>;
  createConversation(data: any): Promise<{ id: string }>;
  logAction(data: any): Promise<void>;
  getRecentActions(limit: number): Promise<any[]>;
  getStats(): Promise<any>;
}

================
File: hooks/database-tracking-hook.ts
================
/**
 * Database Tracking Hook - Populates database with execution data
 * This is what was missing! No hook was actually writing to the database.
 */

import { Hook, HookContext, HookResult, HookEvent } from '../core/hook-orchestrator.js';
import { Logger } from '../core/logger.js';
import { v4 as uuidv4 } from 'uuid';

const logger = Logger.getInstance();

export const databaseTrackingHook: Hook = {
  name: 'database-tracking-hook',
  events: [
    HookEvent.EXECUTION_STARTED,
    HookEvent.EXECUTION_STREAM,
    HookEvent.EXECUTION_COMPLETED,
    HookEvent.EXECUTION_FAILED
  ],
  priority: 90, // Run early to ensure database is populated
  
  handler: async (context: HookContext): Promise<HookResult> => {
    const { event, execution, stream, request, db } = context;
    
    if (!db) {
      logger.warn('DatabaseTrackingHook', 'handler', 'No database in context');
      return { action: 'continue' };
    }
    
    const taskId = execution?.taskId || uuidv4();
    
    try {
      switch (event) {
        case HookEvent.EXECUTION_STARTED:
          logger.info('DatabaseTrackingHook', 'EXECUTION_STARTED', 'Creating conversation', { taskId });
          
          // Create conversation - ID is auto-generated by the DB
          const conversationId = await db.createConversation({
            parent_id: null,
            started_at: new Date().toISOString(),
            status: 'active',
            depth: 0,
            prompt: request?.args?.prompt || request?.args?.parentPrompt || '',
            task_type: request?.tool || 'axiom_spawn',
            metadata: {
              verboseMasterMode: request?.args?.verboseMasterMode || false,
              spawnPattern: request?.args?.spawnPattern || 'single',
              timestamp: new Date().toISOString(),
              originalTaskId: taskId
            }
          });
          
          // Store the actual conversation ID for later use
          context.execution!.taskId = conversationId;
          
          await db.logAction({
            conversation_id: conversationId,
            type: 'execution_started',
            content: 'Task execution started',
            metadata: { event: 'EXECUTION_STARTED' }
          });
          break;
          
        case HookEvent.EXECUTION_STREAM:
          const streamData = stream?.data || '';
          
          // Get the actual conversation ID from context
          const convId = context.execution?.taskId || taskId;
          
          // Log stream data
          await db.logStream({
            conversation_id: convId,
            chunk: streamData
          });
          
          // Also log significant events as actions
          if (streamData.includes('[AXIOM')) {
            await db.logAction({
              conversation_id: convId,
              type: 'axiom_event',
              content: streamData.slice(0, 100),
              metadata: { stream: true }
            });
          }
          break;
          
        case HookEvent.EXECUTION_COMPLETED: {
          logger.info('DatabaseTrackingHook', 'EXECUTION_COMPLETED', 'Updating conversation', { taskId });
          
          const convId = context.execution?.taskId || taskId;
          
          await db.updateConversation(convId, {
            status: 'completed',
            metadata: {
              completed_at: new Date().toISOString(),
              output: execution?.output || ''
            }
          });
          
          await db.logAction({
            conversation_id: convId,
            type: 'execution_completed',
            content: 'Task execution completed successfully',
            metadata: { event: 'EXECUTION_COMPLETED' }
          });
          break;
        }
          
        case HookEvent.EXECUTION_FAILED: {
          logger.error('DatabaseTrackingHook', 'EXECUTION_FAILED', 'Task failed', { 
            taskId,
            error: context.metadata?.error 
          });
          
          const convId = context.execution?.taskId || taskId;
          
          await db.updateConversation(convId, {
            status: 'failed',
            metadata: {
              failed_at: new Date().toISOString(),
              error: context.metadata?.error || 'Unknown error'
            }
          });
          
          await db.logAction({
            conversation_id: convId,
            type: 'execution_failed',
            content: `Task failed: ${context.metadata?.error || 'Unknown error'}`,
            metadata: { 
              event: 'EXECUTION_FAILED',
              error: context.metadata?.error 
            }
          });
          break;
        }
      }
    } catch (error) {
      logger.error('DatabaseTrackingHook', 'handler', 'Database operation failed', { 
        taskId,
        event,
        error: error instanceof Error ? error.message : String(error)
      });
    }
    
    return { action: 'continue' };
  }
};

export default databaseTrackingHook;

================
File: hooks/enhanced-verbose-hook.ts
================
/**
 * Enhanced Verbose Monitoring Hook
 * Provides maximum visibility into execution with metrics and pattern detection
 */

import { Hook, HookContext, HookResult, HookEvent } from '../core/hook-orchestrator.js';
import { Logger } from '../core/logger.js';

const logger = Logger.getInstance();

interface StreamMetrics {
  totalChars: number;
  totalLines: number;
  filesCreated: string[];
  filesModified: string[];
  errorsDetected: string[];
  todosDetected: string[];
  commandsExecuted: string[];
  patternsMatched: Map<string, number>;
  languageDetected?: string;
  lastActivity: number;
}

const activeStreams = new Map<string, StreamMetrics>();

// Pattern definitions with names
const PATTERNS = {
  FILE_CREATED: /(?:created?|wrote|generated?)\s+(?:file\s+)?([^\s]+\.(ts|js|py|java|rs|go|md|txt|json))/i,
  FILE_MODIFIED: /(?:updated?|modified?|changed?)\s+(?:file\s+)?([^\s]+\.(ts|js|py|java|rs|go|md|txt|json))/i,
  ERROR: /(?:error|exception|failed|failure):\s*(.+)/i,
  TODO: /(?:TODO|FIXME|XXX):\s*(.+)/i,
  COMMAND: /^\$\s+(.+)|>\s+(.+)/,
  PYTHON_CODE: /(?:def\s+\w+|import\s+\w+|class\s+\w+|print\()/,
  JAVA_CODE: /(?:public\s+class|private\s+\w+|System\.out\.println|import\s+java)/,
  JAVASCRIPT_CODE: /(?:function\s+\w+|const\s+\w+|console\.log|require\(|import\s+{)/,
  PLANNING: /(?:would|could|should|might)\s+(?:create|implement|build)/i,
  IMPLEMENTATION: /(?:creating|implementing|building|writing)\s+/i,
  INTERRUPT_MARKER: /\[INTERRUPT\]|\[INTERVENTION\]/,
};

export const enhancedVerboseHook: Hook = {
  name: 'enhanced-verbose-hook',
  events: [
    HookEvent.EXECUTION_STARTED,
    HookEvent.EXECUTION_STREAM,
    HookEvent.EXECUTION_COMPLETED,
    HookEvent.EXECUTION_FAILED
  ],
  priority: 100, // Highest priority
  
  handler: async (context: HookContext): Promise<HookResult> => {
    const { event, execution, stream, request } = context;
    const taskId = execution?.taskId || 'unknown';
    
    // Check if verbose mode is enabled
    const isVerbose = request?.args?.verboseMasterMode === true;
    if (!isVerbose) {
      return { action: 'continue' };
    }
    
    switch (event) {
      case HookEvent.EXECUTION_STARTED:
        return handleExecutionStart(taskId, context);
        
      case HookEvent.EXECUTION_STREAM:
        return handleStream(taskId, stream?.data || '', context);
        
      case HookEvent.EXECUTION_COMPLETED:
        return handleExecutionComplete(taskId, context);
        
      case HookEvent.EXECUTION_FAILED:
        return handleExecutionFailed(taskId, context);
        
      default:
        return { action: 'continue' };
    }
  }
};

function handleExecutionStart(taskId: string, context: HookContext): HookResult {
  const prompt = context.request?.args?.prompt || context.request?.args?.parentPrompt || '';
  logger.info('EnhancedVerbose', 'handleExecutionStart', 'Starting execution monitoring', {
    taskId,
    prompt: typeof prompt === 'string' ? prompt.slice(0, 100) + '...' : String(prompt)
  });
  
  // Initialize metrics
  activeStreams.set(taskId, {
    totalChars: 0,
    totalLines: 0,
    filesCreated: [],
    filesModified: [],
    errorsDetected: [],
    todosDetected: [],
    commandsExecuted: [],
    patternsMatched: new Map(),
    lastActivity: Date.now()
  });
  
  // Output header
  // Only show header in verbose mode
  logger.info('EnhancedVerboseHook', 'showHeader', '\n' + '='.repeat(80));
  logger.info('EnhancedVerboseHook', 'showHeader', centerText('AXIOM V4 ENHANCED VERBOSE MODE', 80));
  logger.info('EnhancedVerboseHook', 'showHeader', '='.repeat(80));
  logger.info('EnhancedVerboseHook', 'showHeader', `Task ID: ${taskId}`);
  logger.info('EnhancedVerboseHook', 'showHeader', `Started: ${new Date().toISOString()}`);
  logger.info('EnhancedVerboseHook', 'showHeader', `Prompt: ${prompt}`);
  logger.info('EnhancedVerboseHook', 'showHeader', '='.repeat(80) + '\n');
  
  return { action: 'continue' };
}

function handleStream(taskId: string, data: string, context: HookContext): HookResult {
  const metrics = activeStreams.get(taskId);
  if (!metrics) return { action: 'continue' };
  
  // Update basic metrics
  metrics.totalChars += data.length;
  metrics.totalLines += (data.match(/\n/g) || []).length;
  metrics.lastActivity = Date.now();
  
  // Check all patterns
  const detectedPatterns: string[] = [];
  
  for (const [patternName, pattern] of Object.entries(PATTERNS)) {
    const matches = data.match(pattern);
    if (matches) {
      detectedPatterns.push(patternName);
      
      // Update pattern count
      const count = metrics.patternsMatched.get(patternName) || 0;
      metrics.patternsMatched.set(patternName, count + 1);
      
      // Handle specific patterns
      switch (patternName) {
        case 'FILE_CREATED':
          if (matches[1]) metrics.filesCreated.push(matches[1]);
          break;
        case 'FILE_MODIFIED':
          if (matches[1]) metrics.filesModified.push(matches[1]);
          break;
        case 'ERROR':
          if (matches[1]) metrics.errorsDetected.push(matches[1]);
          break;
        case 'TODO':
          if (matches[1]) metrics.todosDetected.push(matches[1]);
          break;
        case 'COMMAND':
          const cmd = matches[1] || matches[2];
          if (cmd) metrics.commandsExecuted.push(cmd);
          break;
        case 'PYTHON_CODE':
          metrics.languageDetected = 'Python';
          break;
        case 'JAVA_CODE':
          metrics.languageDetected = 'Java';
          break;
      }
    }
  }
  
  // Log the stream with metadata
  logger.logStream('EnhancedVerbose', taskId, data, {
    patterns: detectedPatterns,
    metrics: {
      chars: metrics.totalChars,
      lines: metrics.totalLines,
      files: metrics.filesCreated.length + metrics.filesModified.length
    }
  });
  
  // Real-time pattern alerts
  if (detectedPatterns.length > 0) {
    for (const pattern of detectedPatterns) {
      const alert = formatAlert(pattern, data);
      if (alert) logger.warn('EnhancedVerboseHook', 'processStream', alert);
    }
  }
  
  // Check for interrupt markers
  if (detectedPatterns.includes('INTERRUPT_MARKER')) {
    logger.warn('EnhancedVerbose', 'handleStream', 'INTERRUPT DETECTED!', { taskId, data });
    return {
      action: 'modify',
      modifications: {
        interrupted: true,
        interruptTime: Date.now()
      }
    };
  }
  
  return { action: 'continue' };
}

function handleExecutionComplete(taskId: string, context: HookContext): HookResult {
  const metrics = activeStreams.get(taskId);
  if (!metrics) return { action: 'continue' };
  
  const duration = Date.now() - (activeStreams.get(taskId)?.lastActivity || Date.now());
  
  // Output summary
  logger.info('EnhancedVerboseHook', 'showSummary', '\n' + '='.repeat(80));
  logger.info('EnhancedVerboseHook', 'showSummary', centerText('EXECUTION COMPLETE', 80));
  logger.info('EnhancedVerboseHook', 'showSummary', '='.repeat(80));
  logger.info('EnhancedVerboseHook', 'showSummary', `Task ID: ${taskId}`);
  logger.info('EnhancedVerboseHook', 'showSummary', `Duration: ${duration}ms`);
  logger.info('EnhancedVerboseHook', 'showSummary', '\nMETRICS:');
  logger.info('EnhancedVerboseHook', 'showSummary', `  Total Characters: ${metrics.totalChars}`);
  logger.info('EnhancedVerboseHook', 'showSummary', `  Total Lines: ${metrics.totalLines}`);
  logger.info('EnhancedVerboseHook', 'showSummary', `  Files Created: ${metrics.filesCreated.length}`);
  logger.info('EnhancedVerboseHook', 'showSummary', `  Files Modified: ${metrics.filesModified.length}`);
  logger.info('EnhancedVerboseHook', 'showSummary', `  Errors Detected: ${metrics.errorsDetected.length}`);
  logger.info('EnhancedVerboseHook', 'showSummary', `  TODOs Detected: ${metrics.todosDetected.length}`);
  logger.info('EnhancedVerboseHook', 'showSummary', `  Commands Executed: ${metrics.commandsExecuted.length}`);
  logger.info('EnhancedVerboseHook', 'showSummary', `  Language Detected: ${metrics.languageDetected || 'Unknown'}`);
  
  logger.info('EnhancedVerboseHook', 'showSummary', '\nPATTERN MATCHES:');
  for (const [pattern, count] of metrics.patternsMatched) {
    logger.info('EnhancedVerboseHook', 'showSummary', `  ${pattern}: ${count}`);
  }
  
  if (metrics.filesCreated.length > 0) {
    logger.info('EnhancedVerboseHook', 'showSummary', '\nFILES CREATED:');
    for (const file of metrics.filesCreated) {
      console.error(`  ✓ ${file}`);
    }
  }
  
  if (metrics.errorsDetected.length > 0) {
    console.error('\nERRORS:');
    for (const error of metrics.errorsDetected) {
      console.error(`  ✗ ${error}`);
    }
  }
  
  console.error('='.repeat(80) + '\n');
  
  // Log final metrics
  logger.logMetrics('EnhancedVerbose', {
    duration,
    totalChars: metrics.totalChars,
    totalLines: metrics.totalLines,
    filesCreated: metrics.filesCreated.length,
    errors: metrics.errorsDetected.length
  });
  
  // Clean up
  activeStreams.delete(taskId);
  
  return { action: 'continue' };
}

function handleExecutionFailed(taskId: string, context: HookContext): HookResult {
  logger.error('EnhancedVerbose', 'handleExecutionFailed', 'Execution failed', {
    taskId,
    error: context.metadata?.error
  });
  
  logger.error('EnhancedVerboseHook', 'handleError', '\n' + '='.repeat(80));
  logger.error('EnhancedVerboseHook', 'handleError', centerText('EXECUTION FAILED', 80));
  logger.error('EnhancedVerboseHook', 'handleError', '='.repeat(80));
  logger.error('EnhancedVerboseHook', 'handleError', `Error: ${context.metadata?.error}`);
  logger.error('EnhancedVerboseHook', 'handleError', '='.repeat(80) + '\n');
  
  activeStreams.delete(taskId);
  
  return { action: 'continue' };
}

function formatAlert(pattern: string, data: string): string | null {
  const alerts: Record<string, string> = {
    FILE_CREATED: '📄 FILE CREATED',
    FILE_MODIFIED: '📝 FILE MODIFIED',
    ERROR: '❌ ERROR DETECTED',
    TODO: '⚠️  TODO DETECTED',
    COMMAND: '$ COMMAND EXECUTED',
    PLANNING: '🤔 PLANNING DETECTED',
    IMPLEMENTATION: '🔨 IMPLEMENTATION STARTED',
    INTERRUPT_MARKER: '🛑 INTERRUPT RECEIVED'
  };
  
  const alert = alerts[pattern];
  if (alert) {
    return `\n${colorize('█'.repeat(40), 'yellow')}\n${colorize(centerText(alert, 40), 'yellow')}\n${colorize('█'.repeat(40), 'yellow')}\n`;
  }
  
  return null;
}

function centerText(text: string, width: number): string {
  const padding = Math.max(0, Math.floor((width - text.length) / 2));
  return ' '.repeat(padding) + text;
}

function colorize(text: string, color: string): string {
  const colors: Record<string, string> = {
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m',
    reset: '\x1b[0m'
  };
  
  return `${colors[color] || ''}${text}${colors.reset}`;
}

export default enhancedVerboseHook;

================
File: hooks/event-bus.ts
================
/**
 * Minimal EventBus interface for v4 hooks
 */

export interface EventBus {
  logEvent(event: {
    taskId: string;
    workerId: string;
    event: string;
    payload: any;
  }): void;
}

================
File: hooks/interrupt-handler-hook.ts
================
/**
 * Interrupt Handler Hook
 * Detects interrupt commands and injects new instructions
 */

import { Hook, HookContext, HookResult, HookEvent } from '../core/hook-orchestrator.js';
import { Logger } from '../core/logger.js';

const logger = Logger.getInstance();

interface InterruptCommand {
  pattern: RegExp;
  action: string;
  replacement?: string;
}

// Interrupt patterns and their actions
const INTERRUPT_COMMANDS: InterruptCommand[] = [
  {
    pattern: /\[INTERRUPT:\s*CHANGE\s+TO\s+JAVA\]/i,
    action: 'change_language',
    replacement: 'Stop. Change the implementation to Java instead. Delete any Python code and rewrite everything in Java.'
  },
  {
    pattern: /\[INTERRUPT:\s*CHANGE\s+TO\s+PYTHON\]/i,
    action: 'change_language',
    replacement: 'Stop. Change the implementation to Python instead. Delete any Java code and rewrite everything in Python.'
  },
  {
    pattern: /\[INTERRUPT:\s*ADD\s+TESTS\]/i,
    action: 'add_tests',
    replacement: 'Stop current work. Add comprehensive unit tests for all the code you just wrote.'
  },
  {
    pattern: /\[INTERRUPT:\s*STOP\]/i,
    action: 'stop',
    replacement: 'Stop all current work immediately. Save your progress and exit.'
  },
  {
    pattern: /\[INTERRUPT:\s*EXPLAIN\]/i,
    action: 'explain',
    replacement: 'Stop and explain what you are currently doing and why.'
  }
];

// Track active interrupts
const activeInterrupts = new Map<string, {
  timestamp: number;
  action: string;
  executed: boolean;
}>();

export const interruptHandlerHook: Hook = {
  name: 'interrupt-handler-hook',
  events: [HookEvent.EXECUTION_STREAM],
  priority: 99, // Very high priority to catch interrupts early
  
  handler: async (context: HookContext): Promise<HookResult> => {
    const { stream, execution } = context;
    const taskId = execution?.taskId || 'unknown';
    const data = stream?.data || '';
    
    logger.trace('InterruptHandler', 'handler', 'Checking for interrupts', {
      taskId,
      dataLength: data.length
    });
    
    // Check for interrupt commands
    for (const cmd of INTERRUPT_COMMANDS) {
      if (cmd.pattern.test(data)) {
        logger.warn('InterruptHandler', 'handler', 'INTERRUPT DETECTED!', {
          taskId,
          action: cmd.action,
          pattern: cmd.pattern.source
        });
        
        // Record the interrupt
        activeInterrupts.set(taskId, {
          timestamp: Date.now(),
          action: cmd.action,
          executed: false
        });
        
        // Log prominent alert
        console.error('\n' + '🛑'.repeat(40));
        console.error('🛑🛑🛑 INTERRUPT RECEIVED 🛑🛑🛑');
        console.error(`Action: ${cmd.action.toUpperCase()}`);
        console.error(`Time: ${new Date().toISOString()}`);
        console.error('🛑'.repeat(40) + '\n');
        
        // Return the interrupt command
        return {
          action: 'modify',
          modifications: {
            command: `\n\n[INTERRUPT ACKNOWLEDGED]\n${cmd.replacement}\n\n`,
            interrupted: true,
            interruptAction: cmd.action,
            interruptTime: Date.now()
          }
        };
      }
    }
    
    // Check if we're in an interrupted state and monitor compliance
    const interrupt = activeInterrupts.get(taskId);
    if (interrupt && !interrupt.executed) {
      // Monitor for compliance with the interrupt
      if (interrupt.action === 'change_language') {
        // Check if language is being changed
        if (data.includes('Java') && interrupt.action.includes('JAVA')) {
          logger.info('InterruptHandler', 'handler', 'Language change to Java detected', { taskId });
          interrupt.executed = true;
        } else if (data.includes('Python') && interrupt.action.includes('PYTHON')) {
          logger.info('InterruptHandler', 'handler', 'Language change to Python detected', { taskId });
          interrupt.executed = true;
        }
        
        // If not complying after 5 seconds, re-inject
        if (Date.now() - interrupt.timestamp > 5000 && !interrupt.executed) {
          logger.warn('InterruptHandler', 'handler', 'Interrupt not followed, re-injecting', { taskId });
          
          return {
            action: 'modify',
            modifications: {
              command: '\n[INTERRUPT REMINDER] You must follow the interrupt instruction immediately!\n',
              forceCompliance: true
            }
          };
        }
      }
    }
    
    return { action: 'continue' };
  }
};

// Export function to manually send interrupts
export function sendInterrupt(taskId: string, interruptType: string): string {
  const interrupt = `[INTERRUPT: ${interruptType.toUpperCase()}]`;
  logger.info('InterruptHandler', 'sendInterrupt', 'Manual interrupt sent', {
    taskId,
    type: interruptType
  });
  
  return interrupt;
}

// Monitor interrupt effectiveness
export function getInterruptStats(): Record<string, any> {
  const stats = {
    total: activeInterrupts.size,
    executed: 0,
    pending: 0,
    avgResponseTime: 0
  };
  
  const responseTimes: number[] = [];
  
  for (const [taskId, interrupt] of activeInterrupts) {
    if (interrupt.executed) {
      stats.executed++;
      responseTimes.push(Date.now() - interrupt.timestamp);
    } else {
      stats.pending++;
    }
  }
  
  if (responseTimes.length > 0) {
    stats.avgResponseTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
  }
  
  return stats;
}

export default interruptHandlerHook;

================
File: hooks/intervention-hook.ts
================
/**
 * Intervention Hook - Detects patterns and injects corrections
 * Demonstrates stream modification capabilities
 */

import { Hook, HookContext, HookResult, HookEvent } from '../core/hook-orchestrator.js';

// Pattern -> Intervention mapping
const interventions = new Map<RegExp, string>([
  [/\bTODO\b/i, 'echo "# WARNING: TODO detected - implement now, not later"\n'],
  [/not implemented/i, 'echo "# ERROR: Missing implementation - writing code now..."\n'],
  [/research needed/i, 'echo "# REDIRECT: Skip research, implement with best practices"\n'],
  [/npm ERR!/i, 'npm install\n'],
  [/command not found: (\w+)/i, 'echo "# Installing missing command..."\n'],
  [/TypeError|ReferenceError/i, 'echo "# JavaScript error detected - checking types..."\n']
]);

// Track recent interventions to avoid loops
const recentInterventions = new Map<string, number>();

export const interventionHook: Hook = {
  name: 'intervention-hook',
  events: [HookEvent.EXECUTION_STREAM],
  priority: 80,
  
  handler: async (context: HookContext): Promise<HookResult> => {
    const { stream, execution } = context;
    
    if (!stream || !stream.data) {
      return { action: 'continue' };
    }
    
    const taskId = execution!.taskId;
    const data = stream.data;
    
    // Check each intervention pattern
    for (const [pattern, command] of interventions) {
      if (pattern.test(data)) {
        // Avoid intervention loops
        const key = `${taskId}-${pattern.source}`;
        const lastIntervention = recentInterventions.get(key) || 0;
        
        if (Date.now() - lastIntervention < 5000) {
          // Skip if we intervened recently
          continue;
        }
        
        console.error(`\n[INTERVENTION] Pattern detected: ${pattern.source}`);
        console.error(`[INTERVENTION] Injecting: ${command.trim()}\n`);
        
        recentInterventions.set(key, Date.now());
        
        return {
          action: 'modify',
          modifications: {
            command,
            reason: `Pattern '${pattern.source}' triggered intervention`
          }
        };
      }
    }
    
    // Check for hanging processes
    if (data.includes('Press CTRL+C to stop') || 
        data.includes('Watching for file changes')) {
      
      console.error('\n[INTERVENTION] Detected hanging process - will timeout\n');
      
      return {
        action: 'modify',
        modifications: {
          command: '\x03', // Ctrl+C
          timeout: 5000
        }
      };
    }
    
    return { action: 'continue' };
  }
};

// Cleanup old interventions periodically
setInterval(() => {
  const now = Date.now();
  for (const [key, time] of recentInterventions) {
    if (now - time > 30000) {
      recentInterventions.delete(key);
    }
  }
}, 10000);

export default interventionHook;

================
File: hooks/monitoring-dashboard-hook.ts
================
/**
 * Monitoring Dashboard Hook
 * Provides real-time metrics and visualization
 */

import { Hook, HookContext, HookResult, HookEvent } from '../core/hook-orchestrator.js';
import { Logger } from '../core/logger.js';

const logger = Logger.getInstance();

interface TaskMetrics {
  taskId: string;
  startTime: number;
  lastUpdate: number;
  status: string;
  metrics: {
    charsProcessed: number;
    linesProcessed: number;
    patternsDetected: Map<string, number>;
    executionSpeed: number; // chars/second
    interventions: number;
    errors: number;
    filesCreated: number;
    currentLanguage?: string;
  };
  timeline: Array<{
    timestamp: number;
    event: string;
    data?: any;
  }>;
}

const activeTasks = new Map<string, TaskMetrics>();
let dashboardInterval: NodeJS.Timeout | null = null;

export const monitoringDashboardHook: Hook = {
  name: 'monitoring-dashboard-hook',
  events: [
    HookEvent.REQUEST_RECEIVED,
    HookEvent.EXECUTION_STARTED,
    HookEvent.EXECUTION_STREAM,
    HookEvent.EXECUTION_INTERVENTION,
    HookEvent.EXECUTION_COMPLETED,
    HookEvent.EXECUTION_FAILED
  ],
  priority: 50, // Medium priority - observing, not modifying
  
  handler: async (context: HookContext): Promise<HookResult> => {
    const { event, execution, stream, request } = context;
    const taskId = execution?.taskId || context.metadata?.taskId || 'unknown';
    
    switch (event) {
      case HookEvent.REQUEST_RECEIVED:
        initializeTask(taskId, context);
        break;
        
      case HookEvent.EXECUTION_STARTED:
        startMonitoring(taskId);
        break;
        
      case HookEvent.EXECUTION_STREAM:
        updateMetrics(taskId, stream?.data || '');
        break;
        
      case HookEvent.EXECUTION_INTERVENTION:
        recordIntervention(taskId, context);
        break;
        
      case HookEvent.EXECUTION_COMPLETED:
      case HookEvent.EXECUTION_FAILED:
        finalizeTask(taskId, event === HookEvent.EXECUTION_COMPLETED ? 'completed' : 'failed');
        break;
    }
    
    return { action: 'continue' };
  }
};

function initializeTask(taskId: string, context: HookContext): void {
  const task: TaskMetrics = {
    taskId,
    startTime: Date.now(),
    lastUpdate: Date.now(),
    status: 'initialized',
    metrics: {
      charsProcessed: 0,
      linesProcessed: 0,
      patternsDetected: new Map(),
      executionSpeed: 0,
      interventions: 0,
      errors: 0,
      filesCreated: 0
    },
    timeline: [{
      timestamp: Date.now(),
      event: 'request_received',
      data: { prompt: typeof (context.request?.args?.prompt || context.request?.args?.parentPrompt) === 'string' 
        ? (context.request?.args?.prompt || context.request?.args?.parentPrompt)?.slice(0, 100) 
        : String(context.request?.args?.prompt || context.request?.args?.parentPrompt) }
    }]
  };
  
  activeTasks.set(taskId, task);
  logger.info('MonitoringDashboard', 'initializeTask', 'Task initialized', { taskId });
}

function startMonitoring(taskId: string): void {
  const task = activeTasks.get(taskId);
  if (!task) return;
  
  task.status = 'running';
  task.timeline.push({
    timestamp: Date.now(),
    event: 'execution_started'
  });
  
  // Start dashboard refresh if not already running
  if (!dashboardInterval && activeTasks.size > 0) {
    dashboardInterval = setInterval(renderDashboard, 1000);
  }
}

function updateMetrics(taskId: string, data: string): void {
  const task = activeTasks.get(taskId);
  if (!task) return;
  
  const now = Date.now();
  const timeDelta = (now - task.lastUpdate) / 1000; // seconds
  
  // Update basic metrics
  task.metrics.charsProcessed += data.length;
  task.metrics.linesProcessed += (data.match(/\n/g) || []).length;
  
  // Calculate execution speed
  if (timeDelta > 0) {
    task.metrics.executionSpeed = data.length / timeDelta;
  }
  
  // Detect patterns
  if (/error|exception|failed/i.test(data)) {
    task.metrics.errors++;
    updatePattern(task, 'ERROR');
  }
  
  if (/created?\s+\w+\.(ts|js|py|java)/i.test(data)) {
    task.metrics.filesCreated++;
    updatePattern(task, 'FILE_CREATED');
  }
  
  if (/def\s+\w+|import\s+\w+|class\s+\w+/.test(data)) {
    task.metrics.currentLanguage = 'Python';
    updatePattern(task, 'PYTHON_CODE');
  }
  
  if (/public\s+class|System\.out\.println|import\s+java/.test(data)) {
    task.metrics.currentLanguage = 'Java';
    updatePattern(task, 'JAVA_CODE');
  }
  
  task.lastUpdate = now;
}

function recordIntervention(taskId: string, context: HookContext): void {
  const task = activeTasks.get(taskId);
  if (!task) return;
  
  task.metrics.interventions++;
  task.timeline.push({
    timestamp: Date.now(),
    event: 'intervention',
    data: context.metadata
  });
  
  logger.warn('MonitoringDashboard', 'recordIntervention', 'Intervention recorded', {
    taskId,
    interventionCount: task.metrics.interventions
  });
}

function finalizeTask(taskId: string, status: string): void {
  const task = activeTasks.get(taskId);
  if (!task) return;
  
  task.status = status;
  task.timeline.push({
    timestamp: Date.now(),
    event: `execution_${status}`
  });
  
  // Log final metrics
  const duration = Date.now() - task.startTime;
  logger.info('MonitoringDashboard', 'finalizeTask', 'Task completed', {
    taskId,
    status,
    duration,
    metrics: Object.fromEntries(
      Object.entries(task.metrics).map(([k, v]) => 
        [k, v instanceof Map ? Object.fromEntries(v) : v]
      )
    )
  });
  
  // Keep task for 60 seconds for review
  setTimeout(() => {
    activeTasks.delete(taskId);
    
    // Stop dashboard if no active tasks
    if (activeTasks.size === 0 && dashboardInterval) {
      clearInterval(dashboardInterval);
      dashboardInterval = null;
    }
  }, 60000);
}

function updatePattern(task: TaskMetrics, pattern: string): void {
  const count = task.metrics.patternsDetected.get(pattern) || 0;
  task.metrics.patternsDetected.set(pattern, count + 1);
}

function renderDashboard(): void {
  if (activeTasks.size === 0) return;
  
  // Clear screen and move cursor to top
  console.error('\x1b[2J\x1b[H');
  
  // Header
  console.error('═'.repeat(100));
  console.error(centerText('AXIOM V4 MONITORING DASHBOARD', 100));
  console.error('═'.repeat(100));
  console.error(`Time: ${new Date().toISOString()} | Active Tasks: ${activeTasks.size}`);
  console.error('═'.repeat(100));
  
  // Task panels
  for (const [taskId, task] of activeTasks) {
    renderTaskPanel(task);
  }
  
  // Footer
  console.error('═'.repeat(100));
  console.error('Press Ctrl+C to exit | Dashboard refreshes every 1s');
}

function renderTaskPanel(task: TaskMetrics): void {
  const duration = (Date.now() - task.startTime) / 1000;
  const status = getStatusIcon(task.status);
  
  console.error('\n┌' + '─'.repeat(98) + '┐');
  console.error(`│ Task: ${task.taskId.slice(-8)} ${status} | Duration: ${duration.toFixed(1)}s | Speed: ${task.metrics.executionSpeed.toFixed(0)} chars/s`.padEnd(98) + '│');
  console.error('├' + '─'.repeat(98) + '┤');
  
  // Metrics row 1
  console.error(`│ Chars: ${formatNumber(task.metrics.charsProcessed)} | Lines: ${formatNumber(task.metrics.linesProcessed)} | Files: ${task.metrics.filesCreated} | Errors: ${task.metrics.errors} | Interventions: ${task.metrics.interventions}`.padEnd(98) + '│');
  
  // Language detection
  if (task.metrics.currentLanguage) {
    console.error(`│ Language: ${task.metrics.currentLanguage}`.padEnd(98) + '│');
  }
  
  // Pattern detection
  if (task.metrics.patternsDetected.size > 0) {
    const patterns = Array.from(task.metrics.patternsDetected.entries())
      .map(([p, c]) => `${p}:${c}`)
      .join(' | ');
    console.error(`│ Patterns: ${patterns}`.padEnd(98) + '│');
  }
  
  // Recent timeline events
  const recentEvents = task.timeline.slice(-3);
  if (recentEvents.length > 0) {
    console.error('├' + '─'.repeat(98) + '┤');
    console.error('│ Recent Events:'.padEnd(98) + '│');
    for (const event of recentEvents) {
      const time = new Date(event.timestamp).toLocaleTimeString();
      console.error(`│   ${time} - ${event.event}`.padEnd(98) + '│');
    }
  }
  
  console.error('└' + '─'.repeat(98) + '┘');
}

function getStatusIcon(status: string): string {
  const icons: Record<string, string> = {
    initialized: '🔵',
    running: '🟢',
    completed: '✅',
    failed: '❌'
  };
  return icons[status] || '⚪';
}

function formatNumber(num: number): string {
  if (num > 1000000) return `${(num / 1000000).toFixed(1)}M`;
  if (num > 1000) return `${(num / 1000).toFixed(1)}K`;
  return num.toString();
}

function centerText(text: string, width: number): string {
  const padding = Math.max(0, Math.floor((width - text.length) / 2));
  return ' '.repeat(padding) + text;
}

// Export function to get current metrics
export function getCurrentMetrics(): Record<string, any> {
  const metrics: Record<string, any> = {
    activeTasks: activeTasks.size,
    tasks: []
  };
  
  for (const [taskId, task] of activeTasks) {
    metrics.tasks.push({
      taskId,
      status: task.status,
      duration: Date.now() - task.startTime,
      metrics: Object.fromEntries(
        Object.entries(task.metrics).map(([k, v]) => 
          [k, v instanceof Map ? Object.fromEntries(v) : v]
        )
      )
    });
  }
  
  return metrics;
}

export default monitoringDashboardHook;

================
File: hooks/parallel-execution-hook.ts
================
/**
 * Parallel Execution Hook - Enables multiple approaches
 * Shows how v4 can dynamically spawn parallel executions
 */

import { Hook, HookContext, HookResult, HookEvent } from '../core/hook-orchestrator.js';
import { Logger } from '../core/logger.js';

const logger = Logger.getInstance();

export const parallelExecutionHook: Hook = {
  name: 'parallel-execution-hook',
  events: [HookEvent.REQUEST_VALIDATED, HookEvent.PARALLEL_MERGE],
  priority: 85,
  
  handler: async (context: HookContext): Promise<HookResult> => {
    const { event, request } = context;
    
    if (event === HookEvent.REQUEST_VALIDATED) {
      // Check if we should parallelize this request
      const args = request?.args;
      
      if (args?.spawnPattern === 'parallel' && args?.spawnCount > 1) {
        logger.info('ParallelExecutionHook', 'spawn', `Spawning ${args.spawnCount} parallel executions`);
        
        // Create variations of the prompt
        const variations = generatePromptVariations(args.prompt, args.spawnCount);
        
        // Redirect to parallel execution
        return {
          action: 'redirect',
          redirect: {
            tool: 'parallel_spawn',
            args: {
              requests: variations.map(prompt => ({
                tool: 'axiom_spawn',
                args: { ...args, prompt, spawnPattern: 'single' }
              }))
            }
          }
        };
      }
    }
    
    if (event === HookEvent.PARALLEL_MERGE) {
      // Merge parallel results
      const results = context.metadata?.results || [];
      
      logger.info('ParallelExecutionHook', 'merge', `Merging ${results.length} results`);
      
      // Simple merge strategy - in real v4, this would be sophisticated
      const bestResult = results.find((r: any) => r.includes('success')) || results[0];
      
      return {
        action: 'modify',
        modifications: {
          mergedResult: `Parallel execution complete. Best result:\n${bestResult}`
        }
      };
    }
    
    return { action: 'continue' };
  }
};

function generatePromptVariations(basePrompt: string, count: number): string[] {
  const variations = [];
  
  // Strategy 1: TypeScript implementation
  variations.push(`${basePrompt} using TypeScript with strict types`);
  
  // Strategy 2: JavaScript with JSDoc
  if (count > 1) {
    variations.push(`${basePrompt} using JavaScript with comprehensive JSDoc comments`);
  }
  
  // Strategy 3: Test-driven approach
  if (count > 2) {
    variations.push(`${basePrompt} using test-driven development, write tests first`);
  }
  
  // Strategy 4: Functional approach
  if (count > 3) {
    variations.push(`${basePrompt} using functional programming patterns`);
  }
  
  return variations.slice(0, count);
}

export default parallelExecutionHook;

================
File: hooks/task-decomposition-hook.ts
================
/**
 * Task Decomposition Hook - Breaks work into 5-10 minute orthogonal tasks
 * Enables multi-threading by identifying independent subtasks
 */

import { Hook, HookContext, HookResult, HookEvent } from '../core/hook-orchestrator.js';
import { Logger } from '../core/logger.js';

const logger = Logger.getInstance();

interface DecomposedTask {
  id: string;
  description: string;
  estimatedMinutes: number;
  dependencies: string[];
  category: 'setup' | 'implementation' | 'testing' | 'integration' | 'documentation';
  parallelizable: boolean;
}

export const taskDecompositionHook: Hook = {
  name: 'task-decomposition-hook',
  events: [HookEvent.REQUEST_RECEIVED],
  priority: 95, // Run early to decompose before validation
  
  handler: async (context: HookContext): Promise<HookResult> => {
    const { request } = context;
    const prompt = request?.args?.prompt || request?.args?.parentPrompt || '';
    
    // Only decompose if explicitly requested or complex task detected
    if (!shouldDecompose(prompt)) {
      return { action: 'continue' };
    }
    
    logger.info('TaskDecompositionHook', 'analyze', 'Analyzing task for decomposition', {
      prompt: prompt.slice(0, 100)
    });
    
    // Decompose into orthogonal subtasks
    const subtasks = decomposeTask(prompt);
    
    if (subtasks.length > 1) {
      logger.info('TaskDecompositionHook', 'decompose', `Decomposed into ${subtasks.length} subtasks`);
      
      // Group parallelizable tasks
      const groups = groupParallelizableTasks(subtasks);
      
      return {
        action: 'modify',
        modifications: {
          request: {
            ...request,
            args: {
              ...request?.args,
              decomposedTasks: subtasks,
              parallelGroups: groups,
              spawnPattern: 'parallel-groups',
              metadata: {
                ...request?.args?.metadata,
                decomposed: true,
                taskCount: subtasks.length,
                parallelGroupCount: groups.length
              }
            }
          }
        }
      };
    }
    
    return { action: 'continue' };
  }
};

function shouldDecompose(prompt: string): boolean {
  const complexIndicators = [
    'implement',
    'create',
    'build',
    'develop',
    'design',
    'refactor',
    'migrate',
    'integrate',
    'multiple',
    'system',
    'api',
    'database',
    'frontend',
    'backend'
  ];
  
  const lowerPrompt = prompt.toLowerCase();
  return complexIndicators.some(indicator => lowerPrompt.includes(indicator));
}

function decomposeTask(prompt: string): DecomposedTask[] {
  const subtasks: DecomposedTask[] = [];
  const lowerPrompt = prompt.toLowerCase();
  
  // Example decomposition patterns
  if (lowerPrompt.includes('rest api')) {
    subtasks.push(
      {
        id: 'api-1',
        description: 'Create API project structure and dependencies',
        estimatedMinutes: 5,
        dependencies: [],
        category: 'setup',
        parallelizable: false
      },
      {
        id: 'api-2',
        description: 'Implement data models and schemas',
        estimatedMinutes: 10,
        dependencies: ['api-1'],
        category: 'implementation',
        parallelizable: false
      },
      {
        id: 'api-3',
        description: 'Create authentication middleware',
        estimatedMinutes: 10,
        dependencies: ['api-1'],
        category: 'implementation',
        parallelizable: true
      },
      {
        id: 'api-4',
        description: 'Implement CRUD endpoints',
        estimatedMinutes: 10,
        dependencies: ['api-2'],
        category: 'implementation',
        parallelizable: true
      },
      {
        id: 'api-5',
        description: 'Add validation and error handling',
        estimatedMinutes: 5,
        dependencies: ['api-4'],
        category: 'implementation',
        parallelizable: true
      },
      {
        id: 'api-6',
        description: 'Write unit tests',
        estimatedMinutes: 10,
        dependencies: ['api-4', 'api-3'],
        category: 'testing',
        parallelizable: true
      },
      {
        id: 'api-7',
        description: 'Create API documentation',
        estimatedMinutes: 5,
        dependencies: ['api-4'],
        category: 'documentation',
        parallelizable: true
      }
    );
  } else if (lowerPrompt.includes('factorial') && lowerPrompt.includes('multiple')) {
    // Decompose factorial in multiple languages
    const languages = ['python', 'javascript', 'java', 'rust', 'go'];
    const detectedLangs = languages.filter(lang => lowerPrompt.includes(lang));
    const targetLangs = detectedLangs.length > 0 ? detectedLangs : ['python', 'javascript', 'java'];
    
    targetLangs.forEach((lang, index) => {
      subtasks.push({
        id: `factorial-${lang}`,
        description: `Implement factorial function in ${lang}`,
        estimatedMinutes: 5,
        dependencies: [],
        category: 'implementation',
        parallelizable: true
      });
    });
    
    // Add testing task
    subtasks.push({
      id: 'factorial-test',
      description: 'Create test cases for all implementations',
      estimatedMinutes: 5,
      dependencies: targetLangs.map(lang => `factorial-${lang}`),
      category: 'testing',
      parallelizable: false
    });
  } else if (lowerPrompt.includes('frontend') && lowerPrompt.includes('backend')) {
    // Full-stack decomposition
    subtasks.push(
      {
        id: 'stack-1',
        description: 'Set up project monorepo structure',
        estimatedMinutes: 5,
        dependencies: [],
        category: 'setup',
        parallelizable: false
      },
      {
        id: 'backend-1',
        description: 'Initialize backend server and database',
        estimatedMinutes: 10,
        dependencies: ['stack-1'],
        category: 'implementation',
        parallelizable: true
      },
      {
        id: 'frontend-1',
        description: 'Initialize frontend framework and routing',
        estimatedMinutes: 10,
        dependencies: ['stack-1'],
        category: 'implementation',
        parallelizable: true
      },
      {
        id: 'backend-2',
        description: 'Implement backend API endpoints',
        estimatedMinutes: 10,
        dependencies: ['backend-1'],
        category: 'implementation',
        parallelizable: false
      },
      {
        id: 'frontend-2',
        description: 'Create frontend components and views',
        estimatedMinutes: 10,
        dependencies: ['frontend-1'],
        category: 'implementation',
        parallelizable: false
      },
      {
        id: 'integration-1',
        description: 'Connect frontend to backend API',
        estimatedMinutes: 5,
        dependencies: ['backend-2', 'frontend-2'],
        category: 'integration',
        parallelizable: false
      }
    );
  }
  
  // If no specific pattern matched, create generic decomposition
  if (subtasks.length === 0) {
    subtasks.push(
      {
        id: 'task-1',
        description: 'Analyze requirements and create plan',
        estimatedMinutes: 5,
        dependencies: [],
        category: 'setup',
        parallelizable: false
      },
      {
        id: 'task-2',
        description: 'Implement core functionality',
        estimatedMinutes: 10,
        dependencies: ['task-1'],
        category: 'implementation',
        parallelizable: false
      },
      {
        id: 'task-3',
        description: 'Add error handling and validation',
        estimatedMinutes: 5,
        dependencies: ['task-2'],
        category: 'implementation',
        parallelizable: true
      },
      {
        id: 'task-4',
        description: 'Write tests',
        estimatedMinutes: 5,
        dependencies: ['task-2'],
        category: 'testing',
        parallelizable: true
      }
    );
  }
  
  return subtasks;
}

function groupParallelizableTasks(tasks: DecomposedTask[]): DecomposedTask[][] {
  const groups: DecomposedTask[][] = [];
  const processed = new Set<string>();
  
  // Group tasks by dependency level
  const levels = new Map<string, number>();
  
  // Calculate dependency levels
  function calculateLevel(taskId: string): number {
    if (levels.has(taskId)) return levels.get(taskId)!;
    
    const task = tasks.find(t => t.id === taskId);
    if (!task) return 0;
    
    if (task.dependencies.length === 0) {
      levels.set(taskId, 0);
      return 0;
    }
    
    const maxDepLevel = Math.max(...task.dependencies.map(dep => calculateLevel(dep)));
    const level = maxDepLevel + 1;
    levels.set(taskId, level);
    return level;
  }
  
  // Calculate levels for all tasks
  tasks.forEach(task => calculateLevel(task.id));
  
  // Group by level
  const tasksByLevel = new Map<number, DecomposedTask[]>();
  tasks.forEach(task => {
    const level = levels.get(task.id) || 0;
    if (!tasksByLevel.has(level)) {
      tasksByLevel.set(level, []);
    }
    tasksByLevel.get(level)!.push(task);
  });
  
  // Create groups from each level
  Array.from(tasksByLevel.keys()).sort().forEach(level => {
    const levelTasks = tasksByLevel.get(level)!;
    const parallelizable = levelTasks.filter(t => t.parallelizable);
    const sequential = levelTasks.filter(t => !t.parallelizable);
    
    // Add sequential tasks as individual groups
    sequential.forEach(task => groups.push([task]));
    
    // Add parallelizable tasks as a group
    if (parallelizable.length > 0) {
      groups.push(parallelizable);
    }
  });
  
  return groups;
}

export default taskDecompositionHook;

================
File: hooks/universal-principles-hook.ts
================
/**
 * Universal Principles Hook - Enforces core Axiom principles
 * Converted from v3 universal-principles.ts
 */

import { Hook, HookContext, HookResult, HookEvent } from '../core/hook-orchestrator.js';

export interface Principle {
  id: string;
  name: string;
  description: string;
  category: 'coding' | 'thinking' | 'execution';
  verificationRule: string;
  examples?: {
    good: string[];
    bad: string[];
  };
}

// Core principles from v3
const PRINCIPLES: Principle[] = [
  {
    id: 'no-orphaned-files',
    name: 'No Orphaned Files',
    description: 'Every file must be connected to the project and imported/used somewhere',
    category: 'coding',
    verificationRule: 'File is imported or referenced by at least one other file',
    examples: {
      good: ['utils.ts imported by index.ts', 'Component used in App.tsx'],
      bad: ['random-test.js with no imports', 'backup.ts.old left in project']
    }
  },
  {
    id: 'no-mocks',
    name: 'No Mocks Ever',
    description: 'Never use mock data, mock functions, or placeholder implementations',
    category: 'coding',
    verificationRule: 'No mock/stub/fake/dummy in code',
    examples: {
      good: ['Real API calls', 'Actual database queries'],
      bad: ['mockUser = { id: 1, name: "Test" }', 'function mockApi() {}']
    }
  },
  {
    id: 'real-execution',
    name: 'Real Execution Only',
    description: 'Every operation must actually execute and produce real results',
    category: 'execution',
    verificationRule: 'Commands produce actual output/files',
    examples: {
      good: ['npm install actually installs', 'File.write() creates real file'],
      bad: ['console.log("Would create file")', '// TODO: implement later']
    }
  },
  {
    id: 'verify-dont-trust',
    name: 'Verify Don\'t Trust',
    description: 'Always verify operations succeeded, never assume',
    category: 'thinking',
    verificationRule: 'Every operation followed by verification',
    examples: {
      good: ['Create file then check it exists', 'Run command then verify output'],
      bad: ['Assume file was created', 'Trust that command worked']
    }
  },
  {
    id: 'no-todos',
    name: 'No TODOs',
    description: 'Implement fully or not at all - no placeholders',
    category: 'coding',
    verificationRule: 'No TODO/FIXME/XXX comments',
    examples: {
      good: ['Complete implementation', 'Working code'],
      bad: ['// TODO: add error handling', 'throw new Error("Not implemented")']
    }
  },
  {
    id: 'action-over-planning',
    name: 'Action Over Planning',
    description: 'Write code immediately, not descriptions of code',
    category: 'thinking',
    verificationRule: 'Files created within 30 seconds',
    examples: {
      good: ['Start with main.ts', 'Create index.html first'],
      bad: ['Let me plan the architecture...', 'First, I\'ll research...']
    }
  },
  {
    id: 'fail-fast',
    name: 'Fail Fast and Loudly',
    description: 'Surface errors immediately with clear messages',
    category: 'execution',
    verificationRule: 'Errors thrown with descriptive messages',
    examples: {
      good: ['throw new Error("File not found: config.json")'],
      bad: ['catch (e) { /* ignore */ }', 'return null on error']
    }
  },
  {
    id: 'temporal-awareness',
    name: 'Temporal Awareness',
    description: 'Always know and state the current time context',
    category: 'thinking',
    verificationRule: 'Time-sensitive operations include timestamps',
    examples: {
      good: ['Log with timestamp', 'Check current date before scheduling'],
      bad: ['Assume it\'s still morning', 'Use hardcoded dates']
    }
  }
];

export const universalPrinciplesHook: Hook = {
  name: 'universal-principles-hook',
  events: [
    HookEvent.REQUEST_RECEIVED,
    HookEvent.EXECUTION_STREAM,
    HookEvent.EXECUTION_COMPLETED
  ],
  priority: 95, // High priority
  
  handler: async (context: HookContext): Promise<HookResult> => {
    const { event } = context;
    
    switch (event) {
      case HookEvent.REQUEST_RECEIVED:
        return handleRequestValidation(context);
        
      case HookEvent.EXECUTION_STREAM:
        return handleStreamMonitoring(context);
        
      case HookEvent.EXECUTION_COMPLETED:
        return handleCompletionVerification(context);
        
      default:
        return { action: 'continue' };
    }
  }
};

async function handleRequestValidation(context: HookContext): Promise<HookResult> {
  const prompt = context.request?.args?.prompt || '';
  
  // Check for planning-only language
  if (/^(plan|design|architect|research|explore|investigate)/i.test(prompt)) {
    return {
      action: 'modify',
      modifications: {
        prompt: prompt.replace(/^(plan|design|architect|research|explore|investigate)/i, 'implement'),
        __principleApplied: 'action-over-planning'
      }
    };
  }
  
  return { action: 'continue' };
}

async function handleStreamMonitoring(context: HookContext): Promise<HookResult> {
  const data = context.stream?.data || '';
  const violations: string[] = [];
  
  // Check for TODOs
  if (/\b(TODO|FIXME|XXX)\b/i.test(data)) {
    violations.push('no-todos');
  }
  
  // Check for mocks
  if (/\b(mock|stub|fake|dummy)\w*\s*=|function\s+mock/i.test(data)) {
    violations.push('no-mocks');
  }
  
  // Check for unimplemented
  if (/not implemented|throw new Error\(['"]Not implemented/i.test(data)) {
    violations.push('real-execution');
  }
  
  // Check for planning without action
  if (/would\s+(create|implement|build)|should\s+(create|implement|build)/i.test(data)) {
    violations.push('action-over-planning');
  }
  
  if (violations.length > 0) {
    const principle = PRINCIPLES.find(p => p.id === violations[0]);
    
    console.error(`\n[PRINCIPLE VIOLATION] ${principle?.name}`);
    console.error(`Description: ${principle?.description}`);
    console.error(`Rule: ${principle?.verificationRule}\n`);
    
    return {
      action: 'modify',
      modifications: {
        command: `echo "[INTERVENTION] Principle violated: ${principle?.name}. ${principle?.description}"\n`,
        violations
      }
    };
  }
  
  return { action: 'continue' };
}

async function handleCompletionVerification(context: HookContext): Promise<HookResult> {
  const output = context.execution?.output || '';
  
  // Check if files were actually created
  const fileCreationClaims = output.match(/created?:?\s+(\S+\.(ts|js|tsx|jsx|py|rs|go))/gi) || [];
  const actualCreations = output.match(/File created:|Successfully created/gi) || [];
  
  if (fileCreationClaims.length > actualCreations.length) {
    console.error('\n[PRINCIPLE WARNING] Verify Don\'t Trust');
    console.error('Claims files were created but no verification found');
    console.error(`Claimed: ${fileCreationClaims.length}, Verified: ${actualCreations.length}\n`);
  }
  
  return { action: 'continue' };
}

// Export individual principle checking functions for other hooks
export function checkPrinciple(code: string, principleId: string): boolean {
  switch (principleId) {
    case 'no-todos':
      return !/\b(TODO|FIXME|XXX)\b/i.test(code);
      
    case 'no-mocks':
      return !/\b(mock|stub|fake|dummy)\w*\s*=|function\s+mock/i.test(code);
      
    case 'real-execution':
      return !/not implemented|throw new Error\(['"]Not implemented/i.test(code);
      
    case 'action-over-planning':
      return !/would\s+(create|implement|build)|should\s+(create|implement|build)/i.test(code);
      
    default:
      return true;
  }
}

export function getPrinciples(category?: string): Principle[] {
  if (category) {
    return PRINCIPLES.filter(p => p.category === category);
  }
  return PRINCIPLES;
}

export default universalPrinciplesHook;

================
File: hooks/validation-hook.ts
================
/**
 * Validation Hook - Ensures concrete deliverables
 * Demonstrates how v4 hooks have full runtime access
 */

import { Hook, HookContext, HookResult, HookEvent } from '../core/hook-orchestrator.js';

export const validationHook: Hook = {
  name: 'validation-hook',
  events: [HookEvent.REQUEST_RECEIVED],
  priority: 100, // High priority - runs first
  
  handler: async (context: HookContext): Promise<HookResult> => {
    const { request } = context;
    
    if (!request || request.tool !== 'axiom_spawn') {
      return { action: 'continue' };
    }
    
    const prompt = request.args.prompt || '';
    
    // Check for concrete action verbs
    const hasActionVerb = /\b(create|implement|write|build|fix|add|update|refactor|test)\b/i.test(prompt);
    
    if (!hasActionVerb) {
      return {
        action: 'block',
        reason: `Task must specify concrete action. Use verbs like: create, implement, write, build, fix.
        
Example: 'Create auth.ts with login functionality' instead of 'Research authentication patterns'`
      };
    }
    
    // Check for specific deliverables
    const hasDeliverables = /\.(ts|js|tsx|jsx|py|rs|go|md|json)/i.test(prompt) ||
                           /\b(component|function|class|module|feature|endpoint|api|test)\b/i.test(prompt);
    
    if (!hasDeliverables) {
      return {
        action: 'block',
        reason: `Task must specify concrete deliverables. Include:
- Specific files (e.g., auth.ts, UserLogin.tsx)
- Components/features (e.g., 'login component', 'auth endpoint')

Be specific about WHAT you want created.`
      };
    }
    
    // Block pure research/planning
    if (/^(research|explore|investigate|consider|look into)/i.test(prompt)) {
      return {
        action: 'redirect',
        redirect: {
          tool: 'axiom_spawn',
          args: {
            ...request.args,
            prompt: prompt.replace(/^(research|explore|investigate)/i, 'Implement')
          }
        }
      };
    }
    
    // Add validation metadata
    return {
      action: 'continue',
      modifications: {
        __validated: true,
        __validationScore: 10
      }
    };
  }
};

export default validationHook;

================
File: hooks/verbose-monitor-hook.ts
================
/**
 * Verbose Monitor Hook - Enables real-time streaming
 * Shows how v4 connects previously orphaned components
 */

import { Hook, HookContext, HookResult, HookEvent } from '../core/hook-orchestrator.js';

// This would import the actual VerboseMonitor
// import { VerboseMonitor } from '../monitors/verbose-monitor.js';

const activeMonitors = new Map<string, any>();

export const verboseMonitorHook: Hook = {
  name: 'verbose-monitor-hook',
  events: [
    HookEvent.EXECUTION_STARTED,
    HookEvent.EXECUTION_STREAM,
    HookEvent.EXECUTION_COMPLETED
  ],
  priority: 90,
  
  handler: async (context: HookContext): Promise<HookResult> => {
    const { event, execution, stream, request } = context;
    
    // Check if verbose mode is enabled
    const isVerbose = request?.args?.verboseMasterMode === true;
    
    if (!isVerbose) {
      return { action: 'continue' };
    }
    
    switch (event) {
      case HookEvent.EXECUTION_STARTED:
        // Create monitor for this execution
        console.error(`\n[VERBOSE MODE] Starting execution: ${execution!.taskId}\n`);
        
        // In real implementation, create VerboseMonitor instance
        activeMonitors.set(execution!.taskId, {
          startTime: Date.now(),
          chunks: []
        });
        
        break;
        
      case HookEvent.EXECUTION_STREAM:
        // Process stream in real-time
        const monitor = activeMonitors.get(execution!.taskId);
        if (monitor && stream) {
          // Real-time output with colors
          const prefix = `[${execution!.taskId.slice(-8)}]`;
          const colored = colorizeOutput(stream.data);
          
          // Output to console
          process.stderr.write(`${prefix} ${colored}`);
          
          // Store for aggregation
          monitor.chunks.push(stream.data);
          
          // Pattern detection
          if (/error|failed/i.test(stream.data)) {
            return {
              action: 'modify',
              modifications: {
                intervention: 'error_detected',
                command: '# Error detected - intervention may be needed\n'
              }
            };
          }
        }
        break;
        
      case HookEvent.EXECUTION_COMPLETED:
        // Clean up monitor
        const finalMonitor = activeMonitors.get(execution!.taskId);
        if (finalMonitor) {
          const duration = Date.now() - finalMonitor.startTime;
          console.error(`\n[VERBOSE MODE] Completed in ${duration}ms\n`);
          activeMonitors.delete(execution!.taskId);
        }
        break;
    }
    
    return { action: 'continue' };
  }
};

function colorizeOutput(text: string): string {
  // Color coding for different patterns
  return text
    .replace(/\b(error|failed|failure)\b/gi, '\x1b[31m$1\x1b[0m') // Red
    .replace(/\b(success|passed|created|updated)\b/gi, '\x1b[32m$1\x1b[0m') // Green
    .replace(/\b(warning|todo|fixme)\b/gi, '\x1b[33m$1\x1b[0m') // Yellow
    .replace(/\b(info|note)\b/gi, '\x1b[34m$1\x1b[0m'); // Blue
}

export default verboseMonitorHook;

================
File: hooks/websocket-monitor-hook.ts
================
/**
 * WebSocket Monitor Hook - Real-time web interface
 * Demonstrates how v4 connects monitoring components
 */

import { Hook, HookContext, HookResult, HookEvent } from '../core/hook-orchestrator.js';
import { WebSocketServer } from 'ws';

let wsServer: WebSocketServer | null = null;
const clients = new Set<any>();

// Initialize WebSocket server on first use
function ensureWebSocketServer() {
  if (!wsServer) {
    wsServer = new WebSocketServer({ port: 8080 });
    
    wsServer.on('connection', (ws) => {
      clients.add(ws);
      console.error('[WebSocket] Client connected');
      
      // Send initial state
      ws.send(JSON.stringify({
        type: 'connected',
        message: 'Connected to Axiom v4 Monitor'
      }));
      
      ws.on('close', () => {
        clients.delete(ws);
        console.error('[WebSocket] Client disconnected');
      });
    });
    
    console.error('[WebSocket] Server started on port 8080');
  }
  return wsServer;
}

export const websocketMonitorHook: Hook = {
  name: 'websocket-monitor-hook',
  events: [
    HookEvent.REQUEST_RECEIVED,
    HookEvent.EXECUTION_STARTED,
    HookEvent.EXECUTION_STREAM,
    HookEvent.EXECUTION_COMPLETED,
    HookEvent.EXECUTION_FAILED,
    HookEvent.EXECUTION_INTERVENTION
  ],
  priority: 70,
  
  handler: async (context: HookContext): Promise<HookResult> => {
    const { event, request, execution, stream } = context;
    
    // Ensure WebSocket server is running
    ensureWebSocketServer();
    
    // Broadcast event to all connected clients
    const message = {
      type: event,
      timestamp: new Date().toISOString(),
      taskId: execution?.taskId,
      data: {}
    };
    
    switch (event) {
      case HookEvent.REQUEST_RECEIVED:
        message.data = {
          tool: request?.tool,
          preview: typeof (request?.args?.prompt || request?.args?.parentPrompt) === 'string' 
            ? (request?.args?.prompt || request?.args?.parentPrompt)?.slice(0, 100) + '...'
            : String(request?.args?.prompt || request?.args?.parentPrompt)
        };
        break;
        
      case HookEvent.EXECUTION_STREAM:
        message.data = {
          stream: stream?.data,
          source: stream?.source
        };
        break;
        
      case HookEvent.EXECUTION_COMPLETED:
        message.data = {
          status: 'completed',
          output: execution?.output?.slice(0, 200) + '...'
        };
        break;
        
      case HookEvent.EXECUTION_FAILED:
        message.data = {
          status: 'failed',
          error: context.metadata?.error
        };
        break;
    }
    
    // Broadcast to all clients
    const payload = JSON.stringify(message);
    for (const client of clients) {
      if (client.readyState === 1) { // OPEN
        client.send(payload);
      }
    }
    
    return { action: 'continue' };
  }
};

export default websocketMonitorHook;

================
File: managers/status-manager.ts
================
import { EventEmitter } from 'events';
import { HookOrchestrator } from '../core/hook-orchestrator.js';

export interface TaskStatus {
  id: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  startTime: number;
  endTime?: number;
  output?: string;
  error?: string;
  metadata?: Record<string, any>;
}

export class StatusManager extends EventEmitter {
  private tasks: Map<string, TaskStatus> = new Map();
  private hookOrchestrator?: HookOrchestrator;
  
  setHookOrchestrator(orchestrator: HookOrchestrator): void {
    this.hookOrchestrator = orchestrator;
  }
  
  createTask(id: string, metadata?: Record<string, any>): TaskStatus {
    const task: TaskStatus = {
      id,
      status: 'pending',
      startTime: Date.now(),
      metadata
    };
    
    this.tasks.set(id, task);
    this.emit('task:created', task);
    
    // v4: Notify hooks
    if (this.hookOrchestrator) {
      this.hookOrchestrator.triggerHooks('STATUS_TASK_CREATED', { metadata: { task } });
    }
    
    return task;
  }
  
  updateTaskStatus(id: string, status: TaskStatus['status'], data?: {
    output?: string;
    error?: string;
    metadata?: Record<string, any>;
  }): void {
    const task = this.tasks.get(id);
    if (!task) return;
    
    task.status = status;
    
    if (data?.output) task.output = data.output;
    if (data?.error) task.error = data.error;
    if (data?.metadata) task.metadata = { ...task.metadata, ...data.metadata };
    
    if (status === 'completed' || status === 'failed') {
      task.endTime = Date.now();
    }
    
    this.emit(`task:${status}`, task);
    
    // v4: Notify hooks
    if (this.hookOrchestrator) {
      this.hookOrchestrator.triggerHooks('STATUS_TASK_UPDATED', { metadata: { task } });
    }
  }
  
  getTask(id: string): TaskStatus | undefined {
    return this.tasks.get(id);
  }
  
  getActiveTasks(): TaskStatus[] {
    return Array.from(this.tasks.values())
      .filter(task => task.status === 'running' || task.status === 'pending');
  }
  
  getAllTasks(): TaskStatus[] {
    return Array.from(this.tasks.values());
  }
  
  getStats(): {
    total: number;
    active: number;
    completed: number;
    failed: number;
    avgDuration: number;
  } {
    const tasks = Array.from(this.tasks.values());
    const completed = tasks.filter(t => t.status === 'completed');
    const failed = tasks.filter(t => t.status === 'failed');
    const active = tasks.filter(t => t.status === 'running' || t.status === 'pending');
    
    const durations = completed
      .filter(t => t.endTime)
      .map(t => t.endTime! - t.startTime);
    
    const avgDuration = durations.length > 0
      ? durations.reduce((a, b) => a + b, 0) / durations.length
      : 0;
    
    return {
      total: tasks.length,
      active: active.length,
      completed: completed.length,
      failed: failed.length,
      avgDuration
    };
  }
  
  clearCompleted(): void {
    const completed = Array.from(this.tasks.entries())
      .filter(([_, task]) => task.status === 'completed' || task.status === 'failed');
    
    for (const [id] of completed) {
      this.tasks.delete(id);
    }
    
    this.emit('tasks:cleared', completed.length);
  }
  
  getTaskTree(rootId: string): TaskStatus[] {
    const tree: TaskStatus[] = [];
    const task = this.tasks.get(rootId);
    
    if (task) {
      tree.push(task);
      
      // Find children (tasks with parent metadata)
      for (const [id, t] of this.tasks) {
        if (t.metadata?.parentId === rootId) {
          tree.push(...this.getTaskTree(id));
        }
      }
    }
    
    return tree;
  }
}

================
File: resources/task-monitor-resource.ts
================
/**
 * Task Monitor Resource - Check running tasks every 30 seconds
 * This provides a way to monitor Axiom executions via MCP
 */

export async function getTaskStatus(db: any): Promise<any> {
  if (!db) {
    return { error: 'Database not connected' };
  }
  
  try {
    // Get all active conversations
    const conversations = await db.getDb().all(`
      SELECT id, prompt, status, started_at, task_type, metadata
      FROM conversations
      WHERE status IN ('active', 'running', 'executing')
      ORDER BY started_at DESC
    `);
    
    // For each active conversation, get recent streams
    const tasksWithStreams = await Promise.all(
      conversations.map(async (conv: any) => {
        const recentStreams = await db.getDb().all(`
          SELECT chunk, timestamp
          FROM streams
          WHERE conversation_id = ?
          ORDER BY timestamp DESC
          LIMIT 10
        `, conv.id);
        
        // Check for violations in recent output
        const violations = checkViolations(recentStreams);
        
        return {
          ...conv,
          recentOutput: recentStreams.map((s: any) => s.chunk).join(''),
          violations,
          needsIntervention: violations.length > 0
        };
      })
    );
    
    return {
      activeTasks: tasksWithStreams,
      timestamp: new Date().toISOString(),
      checkInterval: '30 seconds'
    };
  } catch (error) {
    return { 
      error: error instanceof Error ? error.message : String(error),
      timestamp: new Date().toISOString()
    };
  }
}

function checkViolations(streams: any[]): string[] {
  const violations: string[] = [];
  const output = streams.map(s => s.chunk).join('');
  
  // Check for planning violations
  if (output.match(/TODO:|FIXME:|will implement|let's plan|we should/i)) {
    violations.push('PLANNING_VIOLATION: Detected planning instead of implementation');
  }
  
  // Check for false positive reinforcement
  if (output.match(/successfully analyzed|I've planned|I would create/i)) {
    violations.push('FALSE_POSITIVE: LLM claiming success without creating files');
  }
  
  // Check for research mode
  if (output.match(/let me think|I'll analyze|research mode/i)) {
    violations.push('RESEARCH_MODE: LLM stuck in analysis loop');
  }
  
  return violations;
}

================
File: tools/axiom-claude-orchestrate.ts
================
import { z } from 'zod';
import { spawn, IPty } from 'node-pty';
import { EventEmitter } from 'events';
import { logDebug } from '../core/simple-logger.js';

// Schema for the MCP tool
export const axiomClaudeOrchestrateSchema = z.object({
  action: z.enum(['spawn', 'prompt', 'steer', 'get_output', 'status', 'cleanup']),
  instanceId: z.string(),
  prompt: z.string().optional(),
  lines: z.number().optional().default(20)
});

export type AxiomClaudeOrchestrateParams = z.infer<typeof axiomClaudeOrchestrateSchema>;

// Claude instance state
interface ClaudeInstance {
  id: string;
  pty: IPty;
  buffer: string;
  state: 'starting' | 'ready' | 'working' | 'complete' | 'error';
  createdAt: Date;
  lastActivity: Date;
}

// Global orchestrator
class ClaudeOrchestrator extends EventEmitter {
  private instances: Map<string, ClaudeInstance> = new Map();
  private readonly MAX_INSTANCES = 10;
  private readonly INSTANCE_TIMEOUT = 300000; // 5 minutes
  
  constructor() {
    super();
    // Cleanup old instances periodically
    setInterval(() => this.cleanupStaleInstances(), 60000);
  }

  async spawn(instanceId: string): Promise<string> {
    if (this.instances.has(instanceId)) {
      throw new Error(`Instance ${instanceId} already exists`);
    }

    if (this.instances.size >= this.MAX_INSTANCES) {
      throw new Error(`Maximum instances (${this.MAX_INSTANCES}) reached`);
    }

    logDebug('CLAUDE_ORCHESTRATE', `Spawning Claude instance: ${instanceId}`);

    const pty = spawn('claude', [], {
      name: 'xterm-color',
      cols: 80,
      rows: 30,
      cwd: process.cwd(),
      env: process.env
    });

    const instance: ClaudeInstance = {
      id: instanceId,
      pty,
      buffer: '',
      state: 'starting',
      createdAt: new Date(),
      lastActivity: new Date()
    };

    // Data handler
    pty.onData((data) => {
      instance.buffer += data;
      instance.lastActivity = new Date();
      
      // Detect ready state
      if (instance.state === 'starting' && (data.includes('>') || data.includes('?'))) {
        instance.state = 'ready';
        logDebug('CLAUDE_ORCHESTRATE', `Claude instance ${instanceId} is ready`);
        this.emit('ready', instanceId);
      }
      
      // Log significant events
      if (data.includes('```')) {
        logDebug('CLAUDE_ORCHESTRATE', `Code block detected in ${instanceId}`);
      }
    });

    pty.onExit(() => {
      logDebug('CLAUDE_ORCHESTRATE', `Claude instance ${instanceId} exited`);
      this.instances.delete(instanceId);
    });

    this.instances.set(instanceId, instance);
    
    // Wait for ready state
    await this.waitForReady(instanceId);
    
    return `Claude instance ${instanceId} spawned and ready`;
  }

  async prompt(instanceId: string, text: string): Promise<string> {
    const instance = this.instances.get(instanceId);
    if (!instance) {
      throw new Error(`No instance ${instanceId}`);
    }

    if (instance.state !== 'ready') {
      throw new Error(`Instance ${instanceId} not ready (state: ${instance.state})`);
    }

    logDebug('CLAUDE_ORCHESTRATE', `Sending prompt to ${instanceId}: ${text.substring(0, 50)}...`);

    // Type slowly like a human
    await this.typeSlowly(instance.pty, text);
    
    // Submit
    await new Promise(r => setTimeout(r, 300));
    instance.pty.write('\x0d');
    
    instance.state = 'working';
    instance.lastActivity = new Date();
    
    return `Prompt sent to ${instanceId}`;
  }

  async steer(instanceId: string, newPrompt: string): Promise<string> {
    const instance = this.instances.get(instanceId);
    if (!instance) {
      throw new Error(`No instance ${instanceId}`);
    }

    logDebug('CLAUDE_ORCHESTRATE', `Steering ${instanceId} to: ${newPrompt.substring(0, 50)}...`);

    // Send ESC to interrupt
    instance.pty.write('\x1b');
    await new Promise(r => setTimeout(r, 1000));

    // Send new prompt
    await this.typeSlowly(instance.pty, newPrompt);
    await new Promise(r => setTimeout(r, 300));
    instance.pty.write('\x0d');

    instance.state = 'working';
    instance.lastActivity = new Date();

    return `Instance ${instanceId} steered to new task`;
  }

  getOutput(instanceId: string, lines?: number): string {
    const instance = this.instances.get(instanceId);
    if (!instance) {
      throw new Error(`No instance ${instanceId}`);
    }

    if (lines) {
      const allLines = instance.buffer.split('\n');
      return allLines.slice(-lines).join('\n');
    }

    return instance.buffer;
  }

  getStatus(instanceId: string): any {
    const instance = this.instances.get(instanceId);
    if (!instance) {
      return { exists: false };
    }

    return {
      exists: true,
      id: instance.id,
      state: instance.state,
      bufferSize: instance.buffer.length,
      createdAt: instance.createdAt.toISOString(),
      lastActivity: instance.lastActivity.toISOString(),
      uptime: Date.now() - instance.createdAt.getTime()
    };
  }

  cleanup(instanceId: string): string {
    const instance = this.instances.get(instanceId);
    if (!instance) {
      return `No instance ${instanceId} to cleanup`;
    }

    logDebug('CLAUDE_ORCHESTRATE', `Cleaning up Claude instance ${instanceId}`);
    instance.pty.kill();
    this.instances.delete(instanceId);

    return `Instance ${instanceId} cleaned up`;
  }

  private async typeSlowly(pty: IPty, text: string): Promise<void> {
    for (const char of text) {
      pty.write(char);
      await new Promise(r => setTimeout(r, 50 + Math.random() * 100));
    }
  }

  private async waitForReady(instanceId: string, timeout = 30000): Promise<void> {
    const start = Date.now();
    
    return new Promise((resolve, reject) => {
      const check = () => {
        const instance = this.instances.get(instanceId);
        if (!instance) {
          reject(new Error(`Instance ${instanceId} disappeared`));
          return;
        }

        if (instance.state === 'ready') {
          resolve();
          return;
        }

        if (Date.now() - start > timeout) {
          reject(new Error(`Instance ${instanceId} timeout waiting for ready`));
          return;
        }

        setTimeout(check, 100);
      };
      
      check();
    });
  }

  private cleanupStaleInstances(): void {
    const now = Date.now();
    
    for (const [id, instance] of this.instances) {
      if (now - instance.lastActivity.getTime() > this.INSTANCE_TIMEOUT) {
        logDebug('CLAUDE_ORCHESTRATE', `Cleaning up stale instance ${id}`);
        this.cleanup(id);
      }
    }
  }

  getAllInstances(): string[] {
    return Array.from(this.instances.keys());
  }
}

// Global orchestrator instance
const orchestrator = new ClaudeOrchestrator();

// MCP tool implementation
export async function axiomClaudeOrchestrate(params: AxiomClaudeOrchestrateParams): Promise<any> {
  const { action, instanceId, prompt, lines } = params;

  logDebug('CLAUDE_ORCHESTRATE', `axiom_claude_orchestrate: ${action} on ${instanceId}`);

  switch (action) {
    case 'spawn':
      return await orchestrator.spawn(instanceId);
    
    case 'prompt':
      if (!prompt) throw new Error('Prompt required for prompt action');
      return await orchestrator.prompt(instanceId, prompt);
    
    case 'steer':
      if (!prompt) throw new Error('Prompt required for steer action');
      return await orchestrator.steer(instanceId, prompt);
    
    case 'get_output':
      return {
        instanceId,
        output: orchestrator.getOutput(instanceId, lines),
        truncated: lines !== undefined
      };
    
    case 'status':
      if (instanceId === '*') {
        // Get all instances
        return {
          instances: orchestrator.getAllInstances().map(id => ({
            id,
            ...orchestrator.getStatus(id)
          }))
        };
      }
      return orchestrator.getStatus(instanceId);
    
    case 'cleanup':
      return orchestrator.cleanup(instanceId);
    
    default:
      throw new Error(`Unknown action: ${action}`);
  }
}

================
File: ARCHITECTURE.md
================
# Axiom v4 Architecture

## Visual Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                        MCP Tool Request                          │
│                     (axiom_spawn + args)                         │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                      HookOrchestrator                            │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                  REQUEST_RECEIVED Event                  │    │
│  │  ┌────────────┐  ┌────────────┐  ┌────────────────┐    │    │
│  │  │ Validation │→ │  Pattern   │→ │    Security    │    │    │
│  │  │    Hook    │  │    Hook    │  │     Hook       │    │    │
│  │  └────────────┘  └────────────┘  └────────────────┘    │    │
│  └─────────────────────────────────────────────────────────┘    │
└───────────────────────────────┬─────────────────────────────────┘
                                │ (validated/modified request)
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    EXECUTION_STARTED Event                       │
│  ┌────────────┐  ┌────────────┐  ┌─────────────────────┐       │
│  │  Verbose   │  │ WebSocket  │  │   Metrics Start     │       │
│  │  Monitor   │  │  Monitor   │  │      Hook           │       │
│  └────────────┘  └────────────┘  └─────────────────────┘       │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                         PTY Executor                             │
│                    (or other executors)                          │
└───────────────────────────────┬─────────────────────────────────┘
                                │ (character stream)
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    EXECUTION_STREAM Event                        │
│  ┌────────────┐  ┌─────────────┐  ┌────────────────────┐       │
│  │   Stream   │  │Intervention │  │    WebSocket       │       │
│  │  Monitor   │  │    Hook     │  │    Broadcast       │       │
│  └────────────┘  └──────┬──────┘  └────────────────────┘       │
│                         │ (inject command)                      │
│                         ▼                                       │
│                 ┌───────────────┐                               │
│                 │ PTY.write()   │                               │
│                 └───────────────┘                               │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                   EXECUTION_COMPLETED Event                      │
│  ┌────────────┐  ┌────────────┐  ┌─────────────────────┐       │
│  │  Cleanup   │  │   Store    │  │    Notify           │       │
│  │   Hook     │  │  Results   │  │    Clients          │       │
│  └────────────┘  └────────────┘  └─────────────────────┘       │
└─────────────────────────────────────────────────────────────────┘
```

## Hook Chain Example

When `axiom_spawn` is called with verbose mode and parallel execution:

```
1. REQUEST_RECEIVED
   ├─ ValidationHook (priority: 100)
   │  └─ Validates concrete deliverables
   ├─ ParallelExecutionHook (priority: 85) 
   │  └─ Detects parallel pattern, redirects
   └─ SecurityHook (priority: 80)
      └─ Checks for dangerous operations

2. EXECUTION_STARTED
   ├─ VerboseMonitorHook (priority: 90)
   │  └─ Sets up real-time output
   └─ WebSocketMonitorHook (priority: 70)
      └─ Notifies connected clients

3. EXECUTION_STREAM (continuous)
   ├─ InterventionHook (priority: 80)
   │  └─ Detects patterns, injects fixes
   ├─ VerboseMonitorHook (priority: 90)
   │  └─ Colors and displays output
   └─ WebSocketMonitorHook (priority: 70)
      └─ Broadcasts to dashboard

4. EXECUTION_COMPLETED
   └─ All cleanup hooks run
```

## Parallel Execution Flow

```
                    axiom_spawn (parallel)
                           │
                           ▼
                 ParallelExecutionHook
                           │
        ┌─────────────────┼─────────────────┐
        ▼                 ▼                 ▼
   Approach 1        Approach 2        Approach 3
   (TypeScript)      (JavaScript)       (Python)
        │                 │                 │
        └─────────────────┼─────────────────┘
                          ▼
                   PARALLEL_MERGE Event
                          │
                    Best Result
```

## Hook Priority System

Higher priority = runs first

- 100+ : Critical validation/security
- 90-99: Monitoring setup
- 80-89: Pattern detection
- 70-79: Broadcasting/logging
- 60-69: Metrics/analytics
- 50-59: Optional enhancements
- 0-49 : Low priority cleanup

## Component Connections

Unlike v3 where components were hardcoded together, v4 components connect through events:

```
VerboseMonitor:
  - Subscribes to: EXECUTION_STARTED, EXECUTION_STREAM
  - No direct coupling to executor

WebSocketServer:
  - Subscribes to: All events
  - No knowledge of other components

StreamAggregator:
  - Subscribes to: PARALLEL_MERGE
  - Doesn't know about individual executors
```

## Extension Points

### Adding a New Feature

Instead of modifying core code, add a hook:

```typescript
// Old way (v3): Edit axiom-mcp-spawn.ts
if (args.enableMetrics) {
  // Add metrics code
}

// New way (v4): Add a hook
export const metricsHook: Hook = {
  name: 'metrics-hook',
  events: [EXECUTION_STARTED, EXECUTION_COMPLETED],
  handler: async (context) => {
    // Metrics logic here
  }
};
```

### Custom Executors

Register new executors without touching core:

```typescript
orchestrator.registerExecutor('docker_spawn', new DockerExecutor());
orchestrator.registerExecutor('k8s_spawn', new K8sExecutor());
```

## Benefits

1. **Decoupled**: Components don't know about each other
2. **Extensible**: Add features by adding hooks
3. **Testable**: Mock individual hooks
4. **Observable**: Every action is an event
5. **Modifiable**: Change behavior at runtime

================
File: demo-interrupt.ts
================
/**
 * Simple demonstration of the interrupt system
 * This shows how hooks interact without needing full execution
 */

import { HookOrchestrator, HookEvent } from './core/hook-orchestrator.js';
import { Logger } from './core/logger.js';
import interruptHandlerHook from './hooks/interrupt-handler-hook.js';
import enhancedVerboseHook from './hooks/enhanced-verbose-hook.js';
import monitoringDashboardHook from './hooks/monitoring-dashboard-hook.js';

// Set up logger
const logger = Logger.getInstance();
logger.setLogLevel(0); // TRACE level

console.log('\n🚀 AXIOM V4 INTERRUPT SYSTEM DEMO\n');

// Create a mock orchestrator
const orchestrator = new HookOrchestrator({} as any, {} as any);

// Register our enhanced hooks
orchestrator.registerHook(enhancedVerboseHook);
orchestrator.registerHook(interruptHandlerHook);
orchestrator.registerHook(monitoringDashboardHook);

// Simulate execution
async function simulateExecution() {
  const taskId = 'demo-task-123';
  
  // Start execution
  console.log('📝 Starting execution: "Create a factorial function in Python"\n');
  
  await orchestrator.triggerHooks(HookEvent.EXECUTION_STARTED, {
    execution: { taskId, status: 'running' },
    request: {
      tool: 'axiom_spawn',
      args: {
        prompt: 'Create a factorial function in Python',
        verboseMasterMode: true
      }
    }
  });
  
  // Simulate Python code being written
  const pythonStream = `
Creating factorial.py...

def factorial(n):
    """Calculate factorial of n"""
    if n < 0:
        raise ValueError("Factorial not defined for negative numbers")
    elif n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n - 1)
`;

  console.log('\n📊 Simulating Python code generation...\n');
  
  // Send stream data
  for (const chunk of pythonStream.split('\n')) {
    if (chunk.trim()) {
      await orchestrator.triggerHooks(HookEvent.EXECUTION_STREAM, {
        execution: { taskId, status: 'running' },
        stream: { data: chunk + '\n', source: taskId }
      });
      
      // Small delay to simulate real streaming
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }
  
  console.log('\n🛑 Sending interrupt command...\n');
  
  // Send interrupt
  const interruptResult = await orchestrator.triggerHooks(HookEvent.EXECUTION_STREAM, {
    execution: { taskId, status: 'running' },
    stream: { data: '[INTERRUPT: CHANGE TO JAVA]\n', source: taskId }
  });
  
  if (interruptResult.action === 'modify') {
    console.log('✅ Interrupt detected and processed!');
    console.log('📝 Command to inject:', interruptResult.modifications?.command);
  }
  
  // Simulate Java implementation
  console.log('\n♨️ Simulating Java implementation after interrupt...\n');
  
  const javaStream = `
Deleting factorial.py...
Creating Factorial.java...

public class Factorial {
    public static long factorial(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("Factorial not defined for negative numbers");
        }
        if (n == 0 || n == 1) {
            return 1;
        }
        return n * factorial(n - 1);
    }
    
    public static void main(String[] args) {
        System.out.println("5! = " + factorial(5));
    }
}
`;

  for (const chunk of javaStream.split('\n')) {
    if (chunk.trim()) {
      await orchestrator.triggerHooks(HookEvent.EXECUTION_STREAM, {
        execution: { taskId, status: 'running' },
        stream: { data: chunk + '\n', source: taskId }
      });
      
      await new Promise(resolve => setTimeout(resolve, 50));
    }
  }
  
  // Complete execution
  await orchestrator.triggerHooks(HookEvent.EXECUTION_COMPLETED, {
    execution: { taskId, status: 'completed', output: 'Successfully created Factorial.java' }
  });
  
  console.log('\n✨ Demo complete! Check the logs above to see:');
  console.log('  - Pattern detection (Python/Java code)');
  console.log('  - Interrupt handling');
  console.log('  - Real-time metrics');
  console.log('  - Enhanced logging with colors\n');
}

// Run the demo
simulateExecution().catch(console.error);

================
File: index.ts
================
#!/usr/bin/env node
/**
 * Axiom MCP v4 - Hook-First Architecture
 * Everything flows through the HookOrchestrator
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { 
  ListToolsRequestSchema, 
  CallToolRequestSchema,
  ListResourcesRequestSchema,
  ReadResourceRequestSchema 
} from '@modelcontextprotocol/sdk/types.js';
import { HookOrchestrator } from './core/hook-orchestrator.js';
import { logDebug, getLogFile } from './core/simple-logger.js';
import * as fs from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

// Import real components
import { ConversationDB } from './database/conversation-db.js';
import { EventBus } from './core/event-bus.js';
import { PtyExecutor } from './executors/pty-executor.js';
import { CommandExecutor } from './executors/command-executor.js';
import { StatusManager } from './managers/status-manager.js';
import { SimpleExecutor } from './executors/simple-executor.js';
import { SessionBasedExecutor } from './executors/session-based-executor.js';

// Import built-in hooks
import validationHook from './hooks/validation-hook.js';
import verboseMonitorHook from './hooks/verbose-monitor-hook.js';
import interventionHook from './hooks/intervention-hook.js';
import parallelExecutionHook from './hooks/parallel-execution-hook.js';
import websocketMonitorHook from './hooks/websocket-monitor-hook.js';
import universalPrinciplesHook from './hooks/universal-principles-hook.js';

// Import enhanced hooks
import enhancedVerboseHook from './hooks/enhanced-verbose-hook.js';
import interruptHandlerHook from './hooks/interrupt-handler-hook.js';
import monitoringDashboardHook from './hooks/monitoring-dashboard-hook.js';
import taskDecompositionHook from './hooks/task-decomposition-hook.js';
import databaseTrackingHook from './hooks/database-tracking-hook.js';

async function main() {
  logDebug('MAIN', 'Starting Axiom v4 MCP server');
  
  try {
    
    // Initialize real components
    logDebug('MAIN', 'Initializing components');
    const db = new ConversationDB();
    const eventBus = new EventBus();
    const statusManager = new StatusManager();
    
    await db.initialize();
    await eventBus.initialize();
    logDebug('MAIN', 'Components initialized');
  
  // Create the orchestrator - the heart of v4
  const orchestrator = new HookOrchestrator(db, eventBus, statusManager);
  
  // Set orchestrator on components for bidirectional communication
  db.setHookOrchestrator(orchestrator);
  eventBus.setHookOrchestrator(orchestrator);
  statusManager.setHookOrchestrator(orchestrator);
  
  // Register built-in hooks
  orchestrator.registerHook(validationHook);
  orchestrator.registerHook(verboseMonitorHook);
  orchestrator.registerHook(interventionHook);
  orchestrator.registerHook(parallelExecutionHook);
  orchestrator.registerHook(websocketMonitorHook);
  orchestrator.registerHook(universalPrinciplesHook);
  
  // Register enhanced hooks for maximum visibility
  orchestrator.registerHook(databaseTrackingHook);   // CRITICAL - populate database!
  orchestrator.registerHook(taskDecompositionHook);  // Run early to decompose
  orchestrator.registerHook(enhancedVerboseHook);
  orchestrator.registerHook(interruptHandlerHook);
  orchestrator.registerHook(monitoringDashboardHook);
  
  // Register PTY executor - the only one that works for interactive Claude
  const ptyExecutor = new PtyExecutor({ 
    enableMonitoring: true,
    hookOrchestrator: orchestrator
  });
  orchestrator.registerExecutor('axiom_spawn', ptyExecutor);
  
  // Other executors available but not used
  const sessionExecutor = new SessionBasedExecutor({ 
    hookOrchestrator: orchestrator
  });
  const simpleExecutor = new SimpleExecutor({ 
    hookOrchestrator: orchestrator
  });
  
  // Create MCP server
  const server = new Server(
    {
      name: 'axiom-mcp-v4',
      version: '4.0.0',
    },
    {
      capabilities: {
        tools: {},
        resources: {},
      },
    }
  );
  
  // Tool listing
  server.setRequestHandler(ListToolsRequestSchema, async () => {
    return {
      tools: [
        {
          name: 'axiom_spawn',
          description: 'Execute a task with validation and monitoring. Returns taskId immediately. Use axiom_status to check progress and axiom_output to get results.',
          inputSchema: {
            type: 'object',
            properties: {
              prompt: {
                type: 'string',
                description: 'Task to execute',
              },
              verboseMasterMode: {
                type: 'boolean',
                description: 'Enable real-time verbose output',
                default: false,
              },
              spawnPattern: {
                type: 'string',
                description: 'Execution pattern',
                enum: ['single', 'parallel'],
                default: 'single',
              },
              spawnCount: {
                type: 'number',
                description: 'Number of parallel executions',
                default: 1,
              },
            },
            required: ['prompt'],
          },
        },
        {
          name: 'axiom_send',
          description: 'Send input to a running task (e.g., answer prompts, provide data). Include \\n for Enter key.',
          inputSchema: {
            type: 'object',
            properties: {
              taskId: {
                type: 'string',
                description: 'Task ID to send message to',
              },
              message: {
                type: 'string',
                description: 'Message or command to send',
              },
            },
            required: ['taskId', 'message'],
          },
        },
        {
          name: 'axiom_status',
          description: 'Check task status. Omit taskId to see all tasks. Returns: status, runtime, output lines.',
          inputSchema: {
            type: 'object',
            properties: {
              taskId: {
                type: 'string',
                description: 'Specific task ID (optional, shows all if not provided)',
              },
            },
          },
        },
        {
          name: 'axiom_output',
          description: 'Get task output (stdout/stderr). Use tail parameter to limit lines returned.',
          inputSchema: {
            type: 'object',
            properties: {
              taskId: {
                type: 'string',
                description: 'Task ID to get output from',
              },
              tail: {
                type: 'number',
                description: 'Number of last lines to return (optional)',
              },
            },
            required: ['taskId'],
          },
        },
        {
          name: 'axiom_interrupt',
          description: 'Stop/interrupt a running task with Ctrl+C. Optional followUp command executes after interrupt.',
          inputSchema: {
            type: 'object',
            properties: {
              taskId: {
                type: 'string',
                description: 'Task ID to interrupt',
              },
              followUp: {
                type: 'string',
                description: 'Optional follow-up command to send after interrupt',
              },
            },
            required: ['taskId'],
          },
        },
        {
          name: 'axiom_claude_orchestrate',
          description: 'Control Claude instances: spawn/prompt/steer/get_output/status/cleanup. Enables multi-agent orchestration.',
          inputSchema: {
            type: 'object',
            properties: {
              action: {
                type: 'string',
                enum: ['spawn', 'prompt', 'steer', 'get_output', 'status', 'cleanup'],
                description: 'Action to perform',
              },
              instanceId: {
                type: 'string',
                description: 'Claude instance identifier',
              },
              prompt: {
                type: 'string',
                description: 'Prompt text (for prompt/steer actions)',
              },
              lines: {
                type: 'number',
                description: 'Number of output lines to return (for get_output)',
              },
            },
            required: ['action', 'instanceId'],
          },
        },
      ],
    };
  });
  
  // Tool execution
  server.setRequestHandler(CallToolRequestSchema, async (request, extra) => {
    if (request.params.name === 'axiom_spawn') {
      try {
        // Log to file
        logDebug('MCP', 'axiom_spawn called with args:', request.params.arguments);
        
        // Create notification sender if sendNotification is available
        let notificationSender = undefined;
        if (extra && extra.sendNotification) {
          notificationSender = (taskId: string, data: string) => {
            return extra.sendNotification({
              method: "notifications/message",
              params: {
                level: "info",
                data: `[${taskId}] ${data}`
              }
            });
          };
        }
        
        // ALL execution goes through the orchestrator
        const result = await orchestrator.handleRequest('axiom_spawn', {
          ...request.params.arguments,
          notificationSender
        });
        
        logDebug('MCP', `axiom_spawn returned: ${typeof result}`, result);
        
        // Handle different result types
        let textResponse: string;
        if (typeof result === 'string') {
          textResponse = result;
        } else if (result && typeof result === 'object') {
          // For verbose mode, return a formatted response
          textResponse = JSON.stringify(result, null, 2);
        } else {
          textResponse = String(result);
        }
        
        logDebug('MCP', 'Returning MCP response with text:', textResponse.slice(0, 100));
        
        return {
          content: [
            {
              type: 'text',
              text: textResponse,
            },
          ],
        };
      } catch (error: any) {
        logDebug('MCP', 'Error in axiom_spawn handler', {
          message: error.message,
          stack: error.stack
        });
        return {
          content: [
            {
              type: 'text',
              text: `Error: ${error.message}`,
            },
          ],
          isError: true,
        };
      }
    }
    
    if (request.params.name === 'axiom_send') {
      try {
        logDebug('MCP', 'axiom_send called with args:', request.params.arguments);
        
        const args = request.params.arguments as { taskId: string; message: string };
        const { taskId, message } = args;
        const task = orchestrator.getActiveTask(taskId);
        
        if (!task || task.status !== 'running') {
          return {
            content: [{
              type: 'text',
              text: `Task ${taskId} is not running or not found`
            }],
          };
        }
        
        // Send message to the task's executor
        if (task.executor) {
          // Use writeToTask if available (ProcessExecutor)
          if ('writeToTask' in task.executor && typeof task.executor.writeToTask === 'function') {
            task.executor.writeToTask(taskId, message);
          } else if (task.executor.write) {
            task.executor.write(message);
          } else {
            return {
              content: [{
                type: 'text',
                text: `Task ${taskId} does not support message input`
              }],
            };
          }
          
          logDebug('MCP', `Sent message to task ${taskId}:`, message);
          
          return {
            content: [{
              type: 'text',
              text: `Message sent to ${taskId}: ${message}`
            }],
          };
        } else {
          return {
            content: [{
              type: 'text',
              text: `Task ${taskId} executor not found`
            }],
          };
        }
      } catch (error: any) {
        return {
          content: [{
            type: 'text',
            text: `Error: ${error.message}`
          }],
          isError: true,
        };
      }
    }
    
    if (request.params.name === 'axiom_output') {
      try {
        const args = request.params.arguments as { taskId: string; tail?: number };
        const { taskId, tail } = args;
        const task = orchestrator.getActiveTask(taskId);
        
        if (!task) {
          return {
            content: [{
              type: 'text',
              text: `Task ${taskId} not found`
            }],
          };
        }
        
        let output = task.output || '';
        
        // If tail is specified, return last N lines
        if (tail && tail > 0) {
          const lines = output.split('\n');
          const startIdx = Math.max(0, lines.length - tail);
          output = lines.slice(startIdx).join('\n');
        }
        
        return {
          content: [{
            type: 'text',
            text: output || '(no output yet)'
          }],
        };
      } catch (error: any) {
        return {
          content: [{
            type: 'text',
            text: `Error: ${error.message}`
          }],
          isError: true,
        };
      }
    }
    
    if (request.params.name === 'axiom_interrupt') {
      try {
        const args = request.params.arguments as { taskId: string; followUp?: string };
        const { taskId, followUp } = args;
        const task = orchestrator.getActiveTask(taskId);
        
        if (!task || task.status !== 'running') {
          return {
            content: [{
              type: 'text',
              text: `Task ${taskId} is not running or not found`
            }],
          };
        }
        
        // Send interrupt (Ctrl+C) to the task
        if (task.executor && task.executor.interrupt) {
          task.executor.interrupt();
          logDebug('MCP', `Sent interrupt to task ${taskId}`);
          
          // Send follow-up command if provided
          if (followUp && task.executor.write) {
            setTimeout(() => {
              task.executor.write(followUp + '\n');
              logDebug('MCP', `Sent follow-up to task ${taskId}:`, followUp);
            }, 500); // Small delay to let interrupt process
          }
          
          return {
            content: [{
              type: 'text',
              text: followUp 
                ? `Task ${taskId} interrupted. Follow-up sent: ${followUp}`
                : `Task ${taskId} interrupted`
            }],
          };
        } else {
          return {
            content: [{
              type: 'text',
              text: `Task ${taskId} does not support interruption`
            }],
          };
        }
      } catch (error: any) {
        return {
          content: [{
            type: 'text',
            text: `Error: ${error.message}`
          }],
          isError: true,
        };
      }
    }
    
    if (request.params.name === 'axiom_status') {
      try {
        const { taskId } = request.params.arguments || {};
        
        if (taskId) {
          // Get specific task
          const task = orchestrator.getActiveTask(taskId as string);
          if (!task) {
            return {
              content: [{
                type: 'text',
                text: `Task ${taskId} not found`
              }],
            };
          }
          
          const runtime = Date.now() - task.startTime;
          const status = `[${taskId}] ${task.status.toUpperCase()}\nPrompt: ${task.prompt.slice(0, 50)}...\nRuntime: ${runtime}ms\nOutput lines: ${task.output.split('\n').length}`;
          
          return {
            content: [{
              type: 'text',
              text: status
            }],
          };
        } else {
          // Get all tasks
          const tasks = orchestrator.getAllActiveTasks();
          if (tasks.length === 0) {
            return {
              content: [{
                type: 'text',
                text: 'No active tasks'
              }],
            };
          }
          
          const summary = tasks.map(task => {
            const runtime = task.endTime ? task.endTime - task.startTime : Date.now() - task.startTime;
            return `[${task.taskId}] ${task.status.toUpperCase()} - ${task.prompt.slice(0, 30)}... (${runtime}ms)`;
          }).join('\n');
          
          return {
            content: [{
              type: 'text',
              text: summary
            }],
          };
        }
      } catch (error: any) {
        return {
          content: [{
            type: 'text',
            text: `Error: ${error.message}`
          }],
          isError: true,
        };
      }
    }
    
    if (request.params.name === 'axiom_claude_orchestrate') {
      try {
        const { axiomClaudeOrchestrate } = await import('./tools/axiom-claude-orchestrate.js');
        const result = await axiomClaudeOrchestrate(request.params.arguments as any);
        
        logDebug('MCP', 'axiom_claude_orchestrate result:', result);
        
        return {
          content: [{
            type: 'text',
            text: typeof result === 'string' ? result : JSON.stringify(result, null, 2)
          }],
        };
      } catch (error: any) {
        logDebug('MCP', 'axiom_claude_orchestrate error:', error);
        return {
          content: [{
            type: 'text',
            text: `Error: ${error.message}`
          }],
          isError: true,
        };
      }
    }
    
    throw new Error(`Unknown tool: ${request.params.name}`);
  });
  
  // Resource listing
  server.setRequestHandler(ListResourcesRequestSchema, async () => {
    return {
      resources: [
        {
          uri: 'axiom://status',
          name: 'System Status',
          description: 'Current Axiom v4 system status',
          mimeType: 'application/json',
        },
        {
          uri: 'axiom://logs',
          name: 'Recent Logs',
          description: 'Recent event logs from Axiom v4',
          mimeType: 'text/plain',
        },
        {
          uri: 'axiom://debug',
          name: 'Debug Log',
          description: 'Current debug log file',
          mimeType: 'text/plain',
        },
        {
          uri: 'axiom://help',
          name: 'Axiom v4 Help',
          description: 'Axiom v4 documentation and usage guide',
          mimeType: 'text/markdown',
        },
        {
          uri: 'axiom://tools-guide',
          name: 'Tools Guide for LLMs',
          description: 'Comprehensive guide for using Axiom MCP tools as an LLM terminal',
          mimeType: 'text/markdown',
        },
        {
          uri: 'axiom://claude-control-guide',
          name: 'Claude Control Guide',
          description: 'Step-by-step guide for controlling Claude instances via axiom_spawn',
          mimeType: 'text/markdown',
        },
        {
          uri: 'axiom://integration-guide',
          name: 'Claude Code + Axiom Integration Guide',
          description: 'Complete guide for using Claude Code through Axiom MCP tools',
          mimeType: 'text/markdown',
        },
        {
          uri: 'axiom://quick-start',
          name: 'Axiom Quick Start',
          description: 'Essential quick reference for using Axiom MCP with Claude',
          mimeType: 'text/markdown',
        },
      ],
    };
  });
  
  // Resource reading
  server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
    const { uri } = request.params;
    
    switch (uri) {
      case 'axiom://status':
        return {
          contents: [
            {
              uri,
              mimeType: 'application/json',
              text: JSON.stringify({
                version: '4.0.0',
                status: 'operational',
                hooks: {
                  count: 11,
                  names: [
                    validationHook.name,
                    verboseMonitorHook.name,
                    interventionHook.name,
                    parallelExecutionHook.name,
                    websocketMonitorHook.name,
                    universalPrinciplesHook.name,
                    databaseTrackingHook.name,
                    taskDecompositionHook.name,
                    enhancedVerboseHook.name,
                    interruptHandlerHook.name,
                    monitoringDashboardHook.name,
                  ],
                },
                database: db ? 'connected' : 'disconnected',
                executors: ['axiom_spawn'],
              }, null, 2),
            },
          ],
        };
        
      case 'axiom://logs':
        return {
          contents: [
            {
              uri,
              mimeType: 'text/plain',
              text: 'Axiom v4 uses enhanced logging. Set AXIOM_LOG_LEVEL=TRACE for detailed logs.',
            },
          ],
        };
        
      case 'axiom://debug':
        try {
          const logContent = await fs.readFile(getLogFile(), 'utf-8');
          return {
            contents: [
              {
                uri,
                mimeType: 'text/plain',
                text: logContent || 'No debug logs yet.',
              },
            ],
          };
        } catch (err) {
          return {
            contents: [
              {
                uri,
                mimeType: 'text/plain',
                text: `Debug log file: ${getLogFile()}\nError reading: ${err}`,
              },
            ],
          };
        }
        
      case 'axiom://help':
        return {
          contents: [
            {
              uri,
              mimeType: 'text/markdown',
              text: `# Axiom v4 - Hook-First Architecture

## Usage

\`\`\`typescript
axiom_spawn({
  prompt: "Your task here",
  verboseMasterMode: true,  // Enable enhanced monitoring
  spawnPattern: "single",   // or "parallel"
  spawnCount: 1            // For parallel execution
})
\`\`\`

## Features

- **Validation Hook**: Ensures concrete deliverables
- **Enhanced Verbose Mode**: Maximum visibility with pattern detection
- **Interrupt Handling**: Real-time command injection
- **Monitoring Dashboard**: Live execution metrics
- **Hook-First Design**: Everything flows through hooks

## Interrupt Commands

- \`[INTERRUPT: CHANGE TO JAVA]\` - Switch to Java implementation
- \`[INTERRUPT: CHANGE TO PYTHON]\` - Switch to Python implementation
- \`[INTERRUPT: STOP]\` - Stop execution
- \`[INTERRUPT: ADD TESTS]\` - Add unit tests
- \`[INTERRUPT: EXPLAIN]\` - Explain current actions
`,
            },
          ],
        };
        
      case 'axiom://tools-guide':
        try {
          const toolsGuide = await fs.readFile(join(dirname(fileURLToPath(import.meta.url)), '..', 'AXIOM_MCP_TOOLS_GUIDE.md'), 'utf-8');
          return {
            contents: [
              {
                uri,
                mimeType: 'text/markdown',
                text: toolsGuide,
              },
            ],
          };
        } catch (err) {
          return {
            contents: [
              {
                uri,
                mimeType: 'text/markdown',
                text: '# Tools Guide\n\nError loading guide. Please check AXIOM_MCP_TOOLS_GUIDE.md exists.',
              },
            ],
          };
        }
        
      case 'axiom://claude-control-guide':
        try {
          const controlGuide = await fs.readFile(join(dirname(fileURLToPath(import.meta.url)), '..', 'AXIOM_CLAUDE_CONTROL_GUIDE.md'), 'utf-8');
          return {
            contents: [
              {
                uri,
                mimeType: 'text/markdown',
                text: controlGuide,
              },
            ],
          };
        } catch (err) {
          return {
            contents: [
              {
                uri,
                mimeType: 'text/markdown',
                text: '# Claude Control Guide\n\nError loading guide. Please check AXIOM_CLAUDE_CONTROL_GUIDE.md exists.',
              },
            ],
          };
        }
        
      case 'axiom://integration-guide':
        try {
          const integrationGuide = await fs.readFile(join(dirname(fileURLToPath(import.meta.url)), '..', 'CLAUDE_CODE_AXIOM_INTEGRATION_GUIDE.md'), 'utf-8');
          return {
            contents: [
              {
                uri,
                mimeType: 'text/markdown',
                text: integrationGuide,
              },
            ],
          };
        } catch (err) {
          return {
            contents: [
              {
                uri,
                mimeType: 'text/markdown',
                text: '# Integration Guide\n\nError loading guide. Please check CLAUDE_CODE_AXIOM_INTEGRATION_GUIDE.md exists.',
              },
            ],
          };
        }
        
      case 'axiom://quick-start':
        try {
          const quickStart = await fs.readFile(join(dirname(fileURLToPath(import.meta.url)), '..', 'AXIOM_QUICK_START.md'), 'utf-8');
          return {
            contents: [
              {
                uri,
                mimeType: 'text/markdown',
                text: quickStart,
              },
            ],
          };
        } catch (err) {
          return {
            contents: [
              {
                uri,
                mimeType: 'text/markdown',
                text: '# Quick Start\n\nError loading guide. Please check AXIOM_QUICK_START.md exists.',
              },
            ],
          };
        }
        
      default:
        throw new Error(`Unknown resource: ${uri}`);
    }
  });
  
  // Start the server
  const transport = new StdioServerTransport();
  await server.connect(transport);
  
  // Follow the pattern from other MCP servers
  console.error('Axiom MCP Server v4 running on stdio');
  
  // Show detailed startup messages in debug mode
  if (process.env.AXIOM_LOG_LEVEL === 'DEBUG' || process.env.AXIOM_LOG_LEVEL === 'TRACE') {
    console.error('[Axiom v4] Database:', db.constructor.name);
    console.error('[Axiom v4] Executor:', ptyExecutor.constructor.name);
    console.error('[Axiom v4] Registered hooks:', [
      validationHook.name,
      verboseMonitorHook.name,
      interventionHook.name,
      parallelExecutionHook.name,
      websocketMonitorHook.name,
      universalPrinciplesHook.name,
      taskDecompositionHook.name,
      enhancedVerboseHook.name,
      interruptHandlerHook.name,
      monitoringDashboardHook.name
    ].join(', '));
  }
  } catch (error) {
    throw error;
  }
}

// Start immediately
main().catch((error) => {
  logDebug('MAIN', 'Fatal error caught', {
    message: error.message,
    stack: error.stack
  });
  
  // Only log fatal errors
  if (!process.env.AXIOM_SILENT) {
    console.error('Fatal error:', error);
  }
  process.exit(1);
});

================
File: test-interrupt.ts
================
#!/usr/bin/env node
/**
 * Test script for interrupt handling - Python to Java scenario
 * This demonstrates the enhanced visibility and interrupt injection
 */

import { spawn } from 'child_process';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ANSI color codes
const COLORS = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

console.log(`${COLORS.bright}${COLORS.cyan}
╔═══════════════════════════════════════════════════════════╗
║         AXIOM V4 - INTERRUPT HANDLER TEST                 ║
║                                                           ║
║  Testing: Python → Java Language Change via Interrupt     ║
╚═══════════════════════════════════════════════════════════╝
${COLORS.reset}`);

// Start the MCP server
const serverPath = path.join(__dirname, '../dist-v4/index.js');
const mcpServer = spawn('node', [serverPath], {
  stdio: ['pipe', 'pipe', 'pipe'],
  env: { ...process.env }
});

// Capture server output
mcpServer.stdout.on('data', (data) => {
  process.stdout.write(`${COLORS.green}[SERVER]${COLORS.reset} ${data}`);
});

mcpServer.stderr.on('data', (data) => {
  process.stderr.write(`${COLORS.yellow}[SERVER]${COLORS.reset} ${data}`);
});

// MCP protocol helper
function sendRequest(method: string, params: any = {}) {
  const request = {
    jsonrpc: '2.0',
    id: Date.now(),
    method,
    params
  };
  
  const message = JSON.stringify(request);
  mcpServer.stdin.write(`Content-Length: ${Buffer.byteLength(message)}\r\n\r\n${message}`);
}

// Wait for server to be ready
setTimeout(() => {
  console.log(`\n${COLORS.bright}${COLORS.blue}Step 1: Sending initial request to implement factorial in Python${COLORS.reset}\n`);
  
  // Send the initial request
  sendRequest('tools/call', {
    name: 'axiom_spawn',
    arguments: {
      prompt: 'Create a factorial function in Python. Save it to factorial.py',
      verboseMasterMode: true
    }
  });
  
  // Monitor for Python code detection
  let pythonDetected = false;
  let interruptSent = false;
  
  const monitor = setInterval(() => {
    const output = mcpServer.stderr.read();
    if (output && output.toString().includes('PYTHON_CODE')) {
      pythonDetected = true;
      console.log(`\n${COLORS.bright}${COLORS.green}✓ Python code detected!${COLORS.reset}\n`);
    }
    
    // Send interrupt after detecting Python code
    if (pythonDetected && !interruptSent) {
      interruptSent = true;
      console.log(`\n${COLORS.bright}${COLORS.red}Step 2: SENDING INTERRUPT TO CHANGE TO JAVA${COLORS.reset}\n`);
      
      // This simulates sending an interrupt through the stream
      mcpServer.stdin.write('[INTERRUPT: CHANGE TO JAVA]\n');
      
      setTimeout(() => {
        console.log(`\n${COLORS.bright}${COLORS.magenta}Monitoring for Java implementation...${COLORS.reset}\n`);
      }, 1000);
    }
    
    // Check for Java code
    if (output && output.toString().includes('JAVA_CODE')) {
      console.log(`\n${COLORS.bright}${COLORS.green}✅ SUCCESS! Java code detected after interrupt!${COLORS.reset}\n`);
      clearInterval(monitor);
      
      // Gracefully shut down
      setTimeout(() => {
        console.log(`\n${COLORS.bright}${COLORS.cyan}Test complete. Shutting down...${COLORS.reset}\n`);
        mcpServer.kill();
        process.exit(0);
      }, 2000);
    }
  }, 500);
  
  // Timeout after 30 seconds
  setTimeout(() => {
    console.log(`\n${COLORS.bright}${COLORS.red}Test timed out after 30 seconds${COLORS.reset}\n`);
    mcpServer.kill();
    process.exit(1);
  }, 30000);
  
}, 2000);

// Handle errors
mcpServer.on('error', (error) => {
  console.error(`${COLORS.red}Server error:${COLORS.reset}`, error);
  process.exit(1);
});

process.on('SIGINT', () => {
  console.log(`\n${COLORS.yellow}Interrupted by user${COLORS.reset}`);
  mcpServer.kill();
  process.exit(0);
});



================================================================
End of Codebase
================================================================
